# Shtairir IR (Intermediate Representation)

# Rewrite this to be Rust only.

This document defines a minimal, stable IR for Shtairir programs. Both textual and visual front-ends compile to this IR. Hosts validate and execute IR with capability gating. The design aligns with 01–04 and preserves determinism semantics, capability declarations, and strong typing.

IR v1 focuses on a dataflow/event graph:
- Graph: nodes (block instances), ports, edges, constants, subgraphs (functions), graph I/O.
- Events and data are unified as typed streams with a “kind” marker.
- Scopes: subgraphs with their own inputs/outputs for reusable functions.
- Resource handles: opaque types with explicit close/release nodes.
- Determinism/effects: per-node flags copied from block specs for preflight checks.

Version: ir_version = 1

See also: Executing blocks in hosts
For step-by-step conceptual guidance on how a host resolves and runs a block, see “How a host might execute blocks (conceptual)” in docs/shtairir/02-blocks-and-modules.md.
- Resolve a block via Registry::find_block(...)
- Validate inputs/defaults; then map to a host runtime entrypoint to produce outputs

Concepts

1) Graph
- A Graph is a directed wiring of typed ports between Node instances:
  - nodes: list of Node
  - edges: list of Edge
  - consts: list of Const (canonical literals)
  - inputs: list of GraphInput
  - outputs: list of GraphOutput
  - subgraphs: list of Subgraph (reusable scope/functions)
  - meta: optional metadata (author, created_at, source maps)
- Graph inputs/outputs define the external interface of a program or subgraph.
- Subgraphs are first-class, invoked via a Call node.

2) Node (Node Instance)
- instance_id: unique within graph (string, snake_case recommended)
- ref: BlockRef to module.block@version (e.g., "org.cpc.std/math.add@1.0.0")
- params: name → value (must satisfy block param types; defaults applied when omitted)
- determinism: copied from Block spec: "pure" | "time_dependent" | "entropy_dependent" | "io_dependent"
- effects: list copied from Block spec for static checks; may include capability scopes referencing params
- capability_domains: optional refinement domains (e.g., "net.http" scope host hint)
- ports: derived from Block spec (typed, direction). IR stores only concrete wiring via edges.
- source: optional source-location and visual metadata:
  - ui: { x, y, w, h, color?, label? }
  - text_span: { file?, start_line?, start_col?, end_line?, end_col? }

3) Ports
- Typed and directional:
  - direction: "in" | "out"
  - type: TypeSpec or TypeID (see 03-types; IR uses canonical TypeSpec with a parallel computed TypeID)
  - kind: "data" | "event" (events are push; data edges may buffer, see edges)
  - name: string (per block signature)
  - default: optional literal (inputs/params only)
- Notes:
  - Event ports emit/consume discrete occurrences.
  - Data ports represent values updated over time; edges may carry latest-value or queues.
  - Optional inputs are lowered to Option[T] where needed.

4) Edges
- source: { node_id | const_id | graph_input_id, port }
- target: { node_id | graph_output_id | subgraph_input_id, port }
- kind: "data" | "event" (must match port kind; coercions can change type but not kind)
- buffer: optional policy for data edges:
  - "latest" (default): target always reads most recent value
  - "queue": bounded FIFO; size: UInt
- coercion: optional Coercion annotation applied when type-compatible via allowed rules (see 03-types). Example: { from: "UInt", to: "Decimal", mode: "implicit" }
- TODO: backpressure policy for "queue" buffers and event streams.

5) Constants (Const)
- const_id: unique
- type: TypeSpec/TypeID
- value: canonical literal (validated against type)
- purpose: supply literal values into graph without a node.

6) Events vs Data
- Both are streams on edges with kind marker:
  - event: discrete occurrences; push semantics
  - data: value updates; data edges may buffer per edge.buffer
- Blocks declare their port kinds; IR validator enforces kind compatibility.

7) Scopes / Subgraphs
- Subgraph:
  - name: optional CamelCase string (unique)
  - inputs: list of GraphInput
  - outputs: list of GraphOutput
  - body: Graph (nested graph with its own nodes/edges/consts)
- Call node:
  - ref_subgraph: name
  - maps input/output ports to outer graph edges
- Subgraphs enable reuse and encapsulation, mapping directly to functions.

8) Resource Handles
- Opaque types referencing host resources (e.g., media, blobs, network connections).
- Must be closed via explicit close/release nodes (e.g., std.resource.close).
- IR validation can warn on unclosed handles if lifetimes escape outputs.

9) Determinism and Effects
- Node determinism and effects are copied from block ref; cannot be arbitrarily changed by the program.
- Graph determinism summary can be computed for diagnostics.
- Capabilities must be granted by host policy before execution.

Serialization


Validation

Minimal rules:
- Type existence and compatibility:
  - All TypeSpecs must be valid and resolvable.
  - Edge types must be compatible; only allowed coercions are applied.
- Port compatibility:
  - Direction and kind ("data" vs "event") must match.
  - Required inputs must be wired or have defaults; params must be provided or have defaults.
- Block reference resolution:
  - module.block@version must exist in registry; determinism/effects copied into node.
- Effects declared:
  - If node has effects, required capabilities must be listed and permitted by host policy. Pure nodes must have no effects.
- Graph I/O:
  - All graph outputs must have a driving source; inputs define externally-supplied ports only.
- Resource handles:
  - Warn if handle types are produced without a reachable close/release path in the same scope.
- Identifiers:
  - instance_id: snake_case [a-z0-9_]+
  - subgraph name: CamelCase recommended; unique per graph.
  - Program ids and Graph I/O ids must be unique within their scope.

Notes
- Determinism propagation: A graph is time_dependent if any reachable node is time_dependent; similarly for entropy/io. Hosts can reject graphs exceeding policy.
- Buffering and backpressure: data edges can be "latest" or "queue"; event backpressure policy is TODO and will be defined alongside runtime scheduling guidance.
- Coercions are metadata only; actual conversion is performed by implicit adapter blocks or runtime supported safe casts when guaranteed by 03-types.