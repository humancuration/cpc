//! gRPC service implementation for OAuth2

use tonic::{Request, Response, Status};
use uuid::Uuid;
use crate::domain::{OAuthProvider, AuthError};
use crate::application::{AuthService, TokenService};
use tracing::{info, error};

// Import the generated protobuf code
// Note: This will be generated by tonic-build from the proto file
include!("../../generated/oauth.rs");

/// gRPC service implementation for OAuth2
pub struct OAuthGrpcService {
    auth_service: std::sync::Arc<AuthService>,
}

impl OAuthGrpcService {
    /// Create a new OAuth gRPC service
    pub fn new(auth_service: std::sync::Arc<AuthService>) -> Self {
        Self { auth_service }
    }
}

#[tonic::async_trait]
impl oauth_service_server::OAuthService for OAuthGrpcService {
    /// Start OAuth authentication flow
    async fn start_auth(
        &self,
        request: Request<StartAuthRequest>,
    ) -> Result<Response<StartAuthResponse>, Status> {
        let req = request.into_inner();
        info!(user_id = %req.user_id, provider = %req.provider, "gRPC StartAuth request received");
        
        let user_id = Uuid::parse_str(&req.user_id)
            .map_err(|e| Status::invalid_argument(format!("Invalid user ID: {}", e)))?;
        
        let provider = OAuthProvider::from_str(&req.provider)
            .map_err(|e| Status::invalid_argument(format!("Invalid provider: {}", e)))?;
        
        let redirect_uri = req.redirect_uri;
        
        match self.auth_service.start_auth(user_id, provider, redirect_uri).await {
            Ok(auth_request) => {
                let response = StartAuthResponse {
                    auth_url: auth_request.auth_url,
                    state: auth_request.state,
                };
                Ok(Response::new(response))
            }
            Err(e) => {
                error!(error = %e, "Failed to start OAuth authentication");
                Err(Status::internal(format!("Failed to start OAuth authentication: {}", e)))
            }
        }
    }
    
    /// Handle OAuth callback
    async fn handle_callback(
        &self,
        request: Request<HandleCallbackRequest>,
    ) -> Result<Response<HandleCallbackResponse>, Status> {
        let req = request.into_inner();
        info!(code = %req.code, state = %req.state, "gRPC HandleCallback request received");
        
        match self.auth_service.handle_callback(req.code, req.state).await {
            Ok((user_id, token, profile)) => {
                let response = HandleCallbackResponse {
                    user_id: user_id.to_string(),
                    token: Some(oauth_token::from_domain(token)),
                    profile: Some(oauth_profile::from_domain(profile)),
                };
                Ok(Response::new(response))
            }
            Err(AuthError::InvalidState) => {
                Err(Status::invalid_argument("Invalid state parameter"))
            }
            Err(AuthError::InvalidAuthorizationCode) => {
                Err(Status::invalid_argument("Invalid authorization code"))
            }
            Err(e) => {
                error!(error = %e, "Failed to handle OAuth callback");
                Err(Status::internal(format!("Failed to handle OAuth callback: {}", e)))
            }
        }
    }
    
    /// Refresh OAuth token
    async fn refresh_token(
        &self,
        request: Request<RefreshTokenRequest>,
    ) -> Result<Response<RefreshTokenResponse>, Status> {
        let req = request.into_inner();
        info!(user_id = %req.user_id, provider = %req.provider, "gRPC RefreshToken request received");
        
        let user_id = Uuid::parse_str(&req.user_id)
            .map_err(|e| Status::invalid_argument(format!("Invalid user ID: {}", e)))?;
        
        let provider = OAuthProvider::from_str(&req.provider)
            .map_err(|e| Status::invalid_argument(format!("Invalid provider: {}", e)))?;
        
        match self.auth_service.refresh_token(user_id, provider).await {
            Ok(token) => {
                let response = RefreshTokenResponse {
                    token: Some(oauth_token::from_domain(token)),
                };
                Ok(Response::new(response))
            }
            Err(AuthError::TokenExpired) => {
                Err(Status::unauthenticated("Token expired"))
            }
            Err(AuthError::TokenRefreshFailed(msg)) => {
                Err(Status::failed_precondition(msg))
            }
            Err(e) => {
                error!(error = %e, "Failed to refresh OAuth token");
                Err(Status::internal(format!("Failed to refresh OAuth token: {}", e)))
            }
        }
    }
    
    /// Get user profile
    async fn get_profile(
        &self,
        request: Request<GetProfileRequest>,
    ) -> Result<Response<GetProfileResponse>, Status> {
        let req = request.into_inner();
        info!(user_id = %req.user_id, provider = %req.provider, "gRPC GetProfile request received");
        
        let user_id = Uuid::parse_str(&req.user_id)
            .map_err(|e| Status::invalid_argument(format!("Invalid user ID: {}", e)))?;
        
        let provider = OAuthProvider::from_str(&req.provider)
            .map_err(|e| Status::invalid_argument(format!("Invalid provider: {}", e)))?;
        
        // Get the current token for the user
        let token = self.auth_service.token_service().get_token(user_id, &provider).await
            .map_err(|e| {
                error!(error = %e, "Failed to get token for user");
                Status::not_found(format!("No valid token found for user: {}", e))
            })?;
        
        // Get the provider adapter
        let adapter = self.auth_service.get_provider(&provider)
            .ok_or_else(|| Status::invalid_argument(format!("Unsupported provider: {}", provider)))?;
        
        // Fetch the profile using the token
        let profile = adapter.fetch_profile(&token).await
            .map_err(|e| {
                error!(error = %e, "Failed to fetch profile");
                Status::internal(format!("Failed to fetch profile: {}", e))
            })?;
        
        let response = GetProfileResponse {
            profile: Some(oauth_profile::from_domain(profile)),
        };
        
        Ok(Response::new(response))
    }
}

/// Conversion methods for OAuthToken
impl oauth_token {
    /// Convert from domain OAuthToken
    pub fn from_domain(token: crate::domain::OAuthToken) -> Self {
        Self {
            access_token: token.access_token,
            refresh_token: token.refresh_token,
            expires_at: token.expires_at.to_rfc3339(),
            scopes: token.scopes,
            provider: token.provider,
        }
    }
    
    /// Convert to domain OAuthToken
    pub fn to_domain(self) -> Result<crate::domain::OAuthToken, AuthError> {
        Ok(crate::domain::OAuthToken::new(
            self.access_token,
            self.refresh_token,
            chrono::DateTime::parse_from_rfc3339(&self.expires_at)
                .map_err(|e| AuthError::SerializationError(format!("Invalid date format: {}", e)))?
                .with_timezone(&chrono::Utc),
            self.scopes,
            self.provider,
        ))
    }
}

/// Conversion methods for OAuthProfile
impl oauth_profile {
    /// Convert from domain OAuthProfile
    pub fn from_domain(profile: crate::domain::OAuthProfile) -> Self {
        Self {
            provider_id: profile.provider_id,
            name: profile.name,
            email: profile.email,
            provider: profile.provider.to_string(),
            avatar_url: profile.avatar_url,
        }
    }
    
    /// Convert to domain OAuthProfile
    pub fn to_domain(self) -> Result<crate::domain::OAuthProfile, AuthError> {
        Ok(crate::domain::OAuthProfile::new(
            self.provider_id,
            self.name,
            self.email,
            OAuthProvider::from_str(&self.provider)?,
            self.avatar_url,
            None, // raw_data not included in gRPC
        ))
    }
}