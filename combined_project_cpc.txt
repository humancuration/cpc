--- Combined Project Text ---
--- Generated on: 2025-07-21T16:06:52.342346 ---
--- Project Root: C:\CodeProjects\cpc ---

--- Note: This file combines various text-based source files from the project. ---
--- Binary files, specific assets, and configured ignore patterns are excluded. ---
--------------------------------------------------------------------------------


--- START FILE: Cargo.toml ---
[workspace]
resolver = "2"
members = [
    "lib",
    "orchestrator",
    "pds",
    "cpc-node"
]

[workspace.dependencies]
tokio = { version = "1.0", features = ["full"] }
libp2p-core = "0.41.0"
libp2p-kad = "0.43.0"
libp2p-bitswap = "0.44.0"
libp2p-gossipsub = "0.47.0"
libp2p-metrics = "0.16.0"
libp2p-tcp = "0.42.0"
libp2p-websocket = "0.45.0"
libp2p-quic = "0.5.0"
blake3 = "1.5.0"
rusqlite = "0.29"
rocksdb = "0.21.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
--- END FILE: Cargo.toml ---


--- START FILE: apps\cpc-node\Cargo.toml ---
[package]
name = "cpc-node"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
cpc-lib = { path = "../lib" }
tokio = { version = "1.0", features = ["full"] }
rusqlite = "0.29"
rocksdb = "0.21.0"
libp2p-metrics = "0.16.0"
--- END FILE: apps\cpc-node\Cargo.toml ---


--- START FILE: apps\cpc-node\src\main.rs ---
//! Cooperative Node for Cooperative Peer Cloud

use cpc_lib::{storage::LruStorage, net::NetworkBuilder, grpc::client::OrchestratorClient, grpc::internal::{NodeRegistrationRequest, Resources}};
use std::error::Error;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    println!("Cooperative Node starting...");

    // Initialize storage backend
    let mut storage = LruStorage::new(1024 * 1024 * 1024 * 10); // 10GB limit

    // Join P2P network
    let mut network = NetworkBuilder::new()
        .with_tcp()
        .with_quic()
        .enable_kademlia()
        .enable_bitswap()
        .build();

    // Create gRPC client and register with orchestrator
    println!("Connecting to orchestrator...");
    let mut client = OrchestratorClient::connect("http://orchestrator:50051".to_string())
        .await
        .expect("Failed to connect to orchestrator");

    println!("Registering node with orchestrator...");
    let response = client.register_node(NodeRegistrationRequest {
        node_id: network.local_peer_id().to_string(),
        resources: Some(Resources {
            memory: 8192, // 8GB
            storage: 100, // 100GB
            cores: 4,
            bandwidth: 100, // 100 Mbps
        }),
        location: "us-west".to_string(),
        capabilities: vec!["storage".to_string(), "compute".to_string()],
    }).await?;

    println!("Registration response: {}", response.message);

    // Keep the node running
    loop {
        // Handle network events
        // Placeholder for actual event handling
        tokio::time::sleep(Duration::from_secs(10)).await;
    }
}
--- END FILE: apps\cpc-node\src\main.rs ---


--- START FILE: apps\cpc-platform\src-tauri\Cargo.toml ---
[package]
name = "pds"
version = "0.1.0"
edition = "2021"

[dependencies]
tauri = { version = "1.6", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
base64 = "0.21"
mime_guess = "2.0"
--- END FILE: apps\cpc-platform\src-tauri\Cargo.toml ---


--- START FILE: apps\cpc-platform\src-tauri\src\commands.rs ---
use std::fs;
use std::path::Path;
use base64::encode;
use tauri::api::file::read_binary;
use tauri::command;

#[derive(serde::Serialize)]
pub struct FilePreview {
    content_type: String,
    data: String,
}

#[command]
pub async fn download_file(path: String) -> Result<(), String> {
    let path = Path::new(&path);
    if !path.exists() {
        return Err("File not found".to_string());
    }

    // In a real implementation, we would stream the file to the user
    // For this example, we'll just log the download
    println!("Downloading file: {:?}", path);
    Ok(())
}

#[command]
pub async fn get_file_preview(path: String) -> Result<FilePreview, String> {
    let path = Path::new(&path);
    if !path.exists() {
        return Err("File not found".to_string());
    }

    let content_type = mime_guess::from_path(path).first_or_octet_stream().to_string();

    // Only read and encode text and image files
    let data = if content_type.starts_with("text/") || content_type.starts_with("image/") {
        match read_binary(&path) {
            Ok(bytes) => encode(bytes),
            Err(e) => return Err(format!("Failed to read file: {}", e)),
        }
    } else {
        String::new()
    };

    Ok(FilePreview {
        content_type,
        data,
    })
}

#[tauri::command]
async fn watch_directory(
    path: String,
    state: State<'_, AppState>
) -> Result<(), String> {
    let mut watcher = state.file_watcher.lock().await;
    watcher.watch(Path::new(&path)).map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
async fn get_conflicts(
    state: State<'_, AppState>
) -> Result<Vec<FileConflict>, String> {
    let resolver = state.conflict_resolver.lock().await;
    Ok(resolver.get_conflicts())
}
--- END FILE: apps\cpc-platform\src-tauri\src\commands.rs ---


--- START FILE: apps\cpc-platform\src-tauri\src\main.rs ---
#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]

mod commands;

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            commands::download_file,
            commands::get_file_preview
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
--- END FILE: apps\cpc-platform\src-tauri\src\main.rs ---


--- START FILE: apps\cpc-studio\Cargo.toml ---
[package]
name = "cpc-studio"
version = "0.1.0"
edition = "2021"

[dependencies]
tauri = { version = "1.0", features = ["api-all"] }
bevy = { version = "0.10", features = ["dynamic", "render", "bevy_winit"] }
cpc-core = { path = "../../cpc-core" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
crossbeam-channel = "0.5"
wgpu = "0.15"
wry = "0.24"
# Permissive image processing library
image = { version = "0.25", default-features = false, features = ["png", "jpeg"] }
bevy_gltf = { version = "0.10", features = [] }
bevy_wgpu = "0.10"
bevy_render = "0.10"
bevy_core_pipeline = "0.10"
bevy_pbr = "0.10"
bevy_asset = "0.10"
bevy_scene = "0.10"
bevy_transform = "0.10"
bevy_hierarchy = "0.10"
bevy_math = "0.10"
bevy_tasks = "0.10"
bevy_ecs = "0.10"
bevy_app = "0.10"
bevy_log = "0.10"
bevy_time = "0.10"
bevy_window = { version = "0.10", features = ["serialize"] }
bevy_utils = "0.10"
bevy_reflect = "0.10"
bevy_core = "0.10"
pollster = "0.3"
--- END FILE: apps\cpc-studio\Cargo.toml ---


--- START FILE: apps\cpc-studio\assets\test\test_script.rs ---
// Test script for thumbnail verification
fn main() {
    println!("This is a test script for thumbnail verification");
}
--- END FILE: apps\cpc-studio\assets\test\test_script.rs ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\+page.svelte ---
<script>
    import { onMount } from 'svelte';
    import { invoke } from '@tauri-apps/api/tauri';
    import { listen } from '@tauri-apps/api/event';
    import CollaboratorCursor from './components/CollaboratorCursor.svelte';
    import { currentPath, assets, selectedAsset } from './stores/assetStore';
    import VersionHistoryViewer from './components/VersionHistoryViewer.svelte';
    import AssetBrowser from './components/AssetBrowser.svelte';
    import EntityInspector from './components/EntityInspector.svelte';
    import SceneHierarchyPanel from './components/SceneHierarchyPanel.svelte';
    import { selectedEntityData } from './stores/sceneStore';
    
    let editorState = {
        activeScene: '',
        selectedEntities: [],
        resources: [],
        collaborators: [] // Added collaborators array
    };
    
    let canvasCtx;
    
    function textureUpdateHandler(event) {
        const base64 = event.detail;
        const img = new Image();
        img.onload = () => {
            canvasCtx.drawImage(img, 0, 0);
        };
        img.src = `data:image/png;base64,${base64}`;
    }
    
    onMount(async () => {
        const canvas = document.getElementById('editor-canvas');
        canvasCtx = canvas.getContext('2d');
        
        // Setup event listeners
        window.addEventListener('texture-update', textureUpdateHandler);
        
        // Initialize editor state
        editorState = await invoke('get_editor_state');
        
        // Set up collaborator listeners
        invoke('subscribe_to_collaborator_updates');
        
        // Listen for command-executed events
        const unlisten = await listen('command-executed', (event) => {
            const payload = event.payload;
            switch(payload.command_type) {
                case 'CreateEntity':
                    sceneStore.addEntity(payload.entity_id, payload.parent_id);
                    break;
                case 'DeleteEntity':
                    sceneStore.removeEntity(payload.entity_id);
                    break;
                case 'ReparentEntity':
                    sceneStore.reparentEntity(payload.entity_id, payload.parent_id);
                    break;
                // Add cases for other command types
            }
        });
        
        return () => {
            window.removeEventListener('texture-update', textureUpdateHandler);
            unlisten();
        };
    });
    // Function to resolve conflicts
    async function resolveConflict(peerId) {
        await invoke('resolve_conflict', { peerId });
    }
    
    // Handle asset selection from AssetBrowser
    function handleAssetSelect(asset) {
        selectedAsset.set(asset);
    }
</script>

<main>
    <h1>CPC Studio Editor</h1>
    
    <div class="editor-layout">
        <div class="left-panel">
            <div class="panel-section">
                <h3>Scene Hierarchy</h3>
                <SceneHierarchyPanel />
            </div>
            <div class="panel-section">
                <h3>Assets</h3>
                <AssetBrowser on:assetSelect={handleAssetSelect} />
            </div>
        </div>
        
        <div class="viewport">
            <h2>Viewport</h2>
            <!-- Bevy rendering will be displayed here -->
            <canvas id="editor-canvas"></canvas>
            
            <!-- Render collaborator cursors -->
            {#each editorState.collaborators as collaborator (collaborator.peer_id)}
                <CollaboratorCursor {collaborator} />
            {/each}
        </div>
        <div class="inspector-panel">
            {#if $selectedEntityData}
                <EntityInspector />
            {:else if selectedAsset}
                <InspectorPanel {selectedAsset} />
                <VersionHistoryViewer asset={selectedAsset} />
            {:else}
                <div class="empty-inspector">
                    <p>Select an entity or asset to inspect</p>
                </div>
            {/if}
    </div>
</div>
</main>

<style>
    .editor-layout {
        display: grid;
        grid-template-columns: 300px 1fr 300px;
        gap: 16px;
        height: 100vh;
    }
    
    .left-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    
    .panel-section {
        border: 1px solid #ccc;
        padding: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        flex: 1;
    }
    
    .panel-section h3 {
        margin-top: 0;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #eee;
    }
    
    .viewport {
        position: relative;
        display: flex;
        flex-direction: column;
    }
    
    .inspector-panel {
        border: 1px solid #ccc;
        padding: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    #editor-canvas {
        width: 100%;
        flex: 1;
        background: #222;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\+page.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\AssetBrowser.svelte ---
<script>
  import { onMount, afterUpdate } from 'svelte';
  import { invoke } from '@tauri-apps/api/tauri';
  import { currentPath, assets } from '../stores/assetStore';
  import { toast } from '@zerodevx/svelte-toast'; // Using a toast library for notifications
  import { createEventDispatcher } from 'svelte';
  
  const dispatch = createEventDispatcher();
  
  // Local state
  let searchTerm = '';
  let isDragging = false;
  let filteredAssets = [];
  
  // Filter assets based on search term
  $: {
    if ($assets) {
      filteredAssets = $assets.filter(asset => 
        asset.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        asset.tags?.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
      );
    }
  }
  
  // Fetch assets when path changes
  $: {
    if ($currentPath !== undefined) {
      fetchAssets();
    }
  }
  
  // Fetch assets from backend
  async function fetchAssets() {
    try {
      const result = await invoke('get_assets_in_path', { 
        path: $currentPath 
      });
      assets.set(result);
    } catch (error) {
      toast.push(`Error loading assets: ${error}`, { theme: { '--toastBackground': '#f44336' } });
    }
  }
  
  // Handle file import via drag-and-drop
  async function handleDrop(event) {
    event.preventDefault();
    isDragging = false;
    
    const files = Array.from(event.dataTransfer.files);
    if (files.length === 0) return;
    
    try {
      // Process each file
      for (const file of files) {
        const result = await invoke('import_asset', {
          filePath: file.path,
          targetPath: $currentPath
        });
        toast.push(`Imported: ${file.name}`);
      }
      
      // Refresh asset list
      fetchAssets();
    } catch (error) {
      toast.push(`Import failed: ${error}`, { theme: { 'toastBackground': '#f44336' } });
    }
  }
  
  // Navigate to a folder
  function navigateToFolder(path) {
    currentPath.set(path);
  }
  
  // Go up one level
  function goUp() {
    if ($currentPath === '') return;
    const pathParts = $currentPath.split('/');
    pathParts.pop();
    currentPath.set(pathParts.join('/'));
  }
  
  // Initialize component
  onMount(() => {
    if ($currentPath === undefined) {
      currentPath.set('');
    }
  });
</script>

<div class="asset-browser"
     on:dragover={() => isDragging = true}
     on:dragleave={() => isDragging = false}
     on:drop={handleDrop}
     class:active-drag={isDragging}>
  
  <!-- Breadcrumb navigation -->
  <div class="breadcrumbs">
    <button on:click={goUp} class="up-button" disabled={$currentPath === ''}>
      ↑
    </button>
    <span class="path-display">/{$currentPath}</span>
  </div>
  
  <!-- Search and filter -->
  <div class="search-bar">
    <input type="text" bind:value={searchTerm} placeholder="Search assets..." />
    <button on:click={() => searchTerm = ''}>Clear</button>
  </div>
  
  <!-- Asset grid -->
  <div class="asset-grid">
    {#each filteredAssets as asset (asset.id)}
      <div class="asset-card" on:click={() => handleSelect(asset)}>
        {#if asset.thumbnail_url}
          <img src={asset.thumbnail_url} alt={asset.name} class="thumbnail" />
        {:else}
          <div class="thumbnail placeholder">
            {asset.type === 'folder' ? '📁' : '📄'}
          </div>
        {/if}
        <div class="asset-name">{asset.name}</div>
        {#if asset.lock_info}
          <div class="lock-indicator" title="Locked by {asset.lock_info.user_name}">🔒</div>
        {/if}
      </div>
    {:else}
      <div class="empty-state">
        {searchTerm ? 'No assets match your search' : 'No assets in this folder'}
      </div>
    {/each}
  </div>
  
  <!-- Drag overlay -->
  {#if isDragging}
    <div class="drag-overlay">
      <div class="drag-message">Drop files to import</div>
    </div>
  {/if}
</div>

<style>
  .asset-browser {
    display: flex;
    flex-direction: column;
    height: 100%;
    position: relative;
  }
  
  .breadcrumbs {
    display: flex;
    align-items: center;
    padding: 8px;
    background-color: #f5f5f5;
    border-bottom: 1px solid #ddd;
  }
  
  .up-button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 4px 8px;
  }
  
  .up-button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  
  .path-display {
    margin-left: 8px;
    font-size: 0.9rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .search-bar {
    padding: 8px;
    display: flex;
    gap: 8px;
  }
  
  .search-bar input {
    flex-grow: 1;
    padding: 6px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  
  .asset-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 16px;
    padding: 16px;
    overflow-y: auto;
    flex-grow: 1;
  }
  
  .asset-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
    transition: transform 0.2s;
  }
  
  .asset-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
  
  .thumbnail {
    width: 100%;
    height: 100px;
    object-fit: cover;
    background-color: #f0f0f0;
  }
  
  .thumbnail.placeholder {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem;
  }
  
  .asset-name {
    margin-top: 8px;
    text-align: center;
    font-size: 0.8rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    width: 100%;
  }
  
  .lock-indicator {
    position: absolute;
    top: 4px;
    right: 4px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
    padding: 2px;
  }
  
  .empty-state {
    grid-column: 1 / -1;
    text-align: center;
    padding: 40px 0;
    color: #888;
  }
  
  .drag-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(33, 150, 243, 0.1);
    border: 2px dashed #2196f3;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }
  
  .drag-message {
    background: white;
    padding: 20px 40px;
    border-radius: 8px;
    font-weight: bold;
    color: #2196f3;
  }
  
  .active-drag {
    background-color: rgba(33, 150, 243, 0.05);
  }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\AssetBrowser.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\AssetPreview.svelte ---
<script>
    import { onMount, onDestroy } from 'svelte';
    import * as THREE from 'three';
    import { Waveform } from '@svicons/ionicons-outline';

    export let asset;
    export let thumbnailUrl = null;
    let canvas;
    let renderer;
    let scene;
    let camera;
    let model = null;
    let thumbnailLoading = false;
    let thumbnailError = false;
    
    // Initialize Three.js for 3D models
    onMount(() => {
        if (asset.asset_type === 'model') {
            initThreeJS();
            loadModel();
        }
    });
    
    // Reset thumbnail state when thumbnailUrl changes
    $: if (thumbnailUrl) {
        thumbnailLoading = true;
        thumbnailError = false;
    }
    
    function initThreeJS() {
        // Setup scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Setup camera
        camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 5;
        
        // Setup renderer
        renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(300, 300);
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            if (model) {
                model.rotation.y += 0.01;
            }
            renderer.render(scene, camera);
        };
        animate();
    }
    
    async function loadModel() {
        // In a real implementation, we would load the model from asset.path
        // For now we'll just create a placeholder cube
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        model = new THREE.Mesh(geometry, material);
        scene.add(model);
    }
    
    onDestroy(() => {
        if (renderer) {
            renderer.dispose();
        }
    });
</script>

<div class="asset-preview">
    {#if asset.asset_type === 'Texture'}
        {#if thumbnailUrl && !thumbnailError}
            <img
                src={thumbnailUrl}
                alt={asset.name}
                class="thumbnail-preview"
                on:load={() => thumbnailLoading = false}
                on:error={() => {
                    thumbnailLoading = false;
                    thumbnailError = true;
                }}
            />
        {:else}
            <div class="generic-preview">
                {#if thumbnailLoading}
                    <div class="loading-spinner">Loading...</div>
                {:else}
                    {asset.asset_type.toUpperCase()}
                {/if}
            </div>
        {/if}
    
    {:else if asset.asset_type === 'model'}
        <canvas bind:this={canvas} class="model-preview"></canvas>
    
    {:else if asset.asset_type === 'audio'}
        <div class="audio-preview">
            <Waveform class="waveform-icon" />
            <audio controls>
                <source src={asset.path} type="audio/mpeg">
                Your browser does not support the audio element.
            </audio>
        </div>
    
    {:else}
        <div class="generic-preview">
            {asset.asset_type.toUpperCase()}
        </div>
    {/if}
</div>

<style>
    .asset-preview {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .thumbnail-preview {
        max-width: 128px;
        max-height: 128px;
        object-fit: contain;
    }
    
    .model-preview {
        width: 300px;
        height: 300px;
    }
    
    .audio-preview {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        width: 100%;
    }
    
    .waveform-icon {
        width: 100px;
        height: 100px;
        color: #666;
    }
    
    .generic-preview {
        font-size: 24px;
        font-weight: bold;
        color: #555;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    
    .loading-spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-left-color: #007bff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\AssetPreview.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\CollaboratorCursor.svelte ---
<script>
    import { onMount } from 'svelte';
    import { getContext } from 'svelte';
    import { invoke } from '@tauri-apps/api/tauri';
    
    export let collaborator;
    
    const canvasContext = getContext('editorCanvas');
    let canvas;
    let ctx;
    
    onMount(() => {
        canvas = canvasContext.canvas;
        ctx = canvas.getContext('2d');
        drawCursor();
    });
    
    function drawCursor() {
        if (!ctx || !collaborator) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = collaborator.cursor_position.x;
        const y = collaborator.cursor_position.y;
        
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y + 10);
        ctx.strokeStyle = `rgb(${collaborator.color.r * 255}, ${collaborator.color.g * 255}, ${collaborator.color.b * 255})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw collaborator name
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText(collaborator.peer_id, x + 12, y + 12);
        
        ctx.restore();
    }
    
    $: if (collaborator) {
        drawCursor();
    }
</script>

<div class="collaborator-cursor">
    {#if collaborator.has_conflict}
        <div class="conflict-indicator" on:click={() => invoke('resolve_conflict', { peerId: collaborator.peer_id })}>
            ⚠️
        </div>
    {/if}
</div>

<style>
    .collaborator-cursor {
        position: absolute;
        pointer-events: none;
        z-index: 100;
    }
    
    .conflict-indicator {
        position: absolute;
        background: rgba(200, 0, 0, 0.7);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        pointer-events: auto;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\CollaboratorCursor.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\InspectorPanel.svelte ---
<script>
    import { selectedEntityData } from '../stores/sceneStore';
    import { dispatchCommand } from '../stores/commandDispatcher';
    import VectorInput from './VectorInput.svelte';
    import AssetInput from './AssetInput.svelte';
    import ColorPicker from './ColorPicker.svelte';
    import { toast } from '@zerodevx/svelte-toast';
    
    let editingComponent = null;
    let editMode = false;

    // Function to handle component updates
    async function updateComponent(entityId, componentName, newValue) {
        try {
            await dispatchCommand('UpdateComponent', {
                entityId,
                componentName,
                componentData: newValue
            });
        } catch (error) {
            toast.push(`Update failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }

    // Function to remove a component
    async function removeComponent(entityId, componentName) {
        try {
            await dispatchCommand('RemoveComponent', {
                entityId,
                componentName
            });
        } catch (error) {
            toast.push(`Remove failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }

    // Function to add a new component
    async function addComponent(entityId, componentName) {
        try {
            await dispatchCommand('AddComponent', {
                entityId,
                componentName
            });
        } catch (error) {
            toast.push(`Add failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }
    
    // Function to render component-specific editors
    function renderComponentEditor(componentName, componentData) {
        switch(componentName) {
            case 'Transform':
                return {
                    editor: VectorInput,
                    props: {
                        values: componentData.translation,
                        onChange: (newValues) => updateComponent($selectedEntityData.id, 'Transform', { ...componentData, translation: newValues })
                    }
                };
            case 'Mesh':
                return {
                    editor: AssetInput,
                    props: {
                        assetId: componentData.asset_id,
                        onSelect: (assetId) => updateComponent($selectedEntityData.id, 'Mesh', { ...componentData, asset_id: assetId })
                    }
                };
            case 'Material':
                return {
                    editor: ColorPicker,
                    props: {
                        color: componentData.base_color,
                        onChange: (newColor) => updateComponent($selectedEntityData.id, 'Material', { ...componentData, base_color: newColor })
                    }
                };
            default:
                return null;
        }
    }
</script>

<div class="inspector-panel">
    <h2>Inspector</h2>
    
    {#if !$selectedEntityData}
        <p>No entity selected</p>
    {:else}
        <div class="entity-info">
            <h3>{$selectedEntityData.components.Name?.value || `Entity ${$selectedEntityData.id.substring(0,4)}`}</h3>
            <div class="property">
                <label>ID:</label>
                <span>{$selectedEntityData.id}</span>
            </div>
            
            {#if $selectedEntityData.parent}
                <div class="property">
                    <label>Parent:</label>
                    <span>{$selectedEntityData.parent}</span>
                </div>
            {/if}
            
            {#if $selectedEntityData.children.length > 0}
                <div class="property">
                    <label>Children:</label>
                    <span>{$selectedEntityData.children.length}</span>
                </div>
            {/if}
        </div>
        
        <div class="components">
            <div class="component-header-row">
                <h4>Components</h4>
                <button on:click={() => editMode = !editMode}>
                    {editMode ? 'Done' : 'Edit'}
                </button>
            </div>
            
            {#each Object.entries($selectedEntityData.components) as [name, component]}
                <div class="component">
                    <div class="component-header">
                        {name}
                        {#if editMode}
                            <button class="remove-btn" on:click={() => removeComponent($selectedEntityData.id, name)}>Remove</button>
                        {/if}
                    </div>
                    
                    {#if renderComponentEditor(name, component)}
                        <svelte:component
                            this={renderComponentEditor(name, component).editor}
                            {...renderComponentEditor(name, component).props}
                        />
                    {:else}
                        <pre class="component-data">{JSON.stringify(component, null, 2)}</pre>
                    {/if}
                </div>
            {/each}
            
            {#if editMode}
                <div class="add-component">
                    <select bind:value={editingComponent}>
                        <option value="">Add Component</option>
                        <option value="Transform">Transform</option>
                        <option value="Mesh">Mesh</option>
                        <option value="Material">Material</option>
                        <option value="Light">Light</option>
                    </select>
                    <button on:click={() => addComponent($selectedEntityData.id, editingComponent)}
                            disabled={!editingComponent}>
                        Add
                    </button>
                </div>
            {/if}
        </div>
    {/if}
</div>

<style>
    .inspector-panel {
        padding: 15px;
        border: 1px solid #ccc;
        height: 100%;
        overflow-y: auto;
    }
    
    .entity-info {
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .property {
        display: flex;
        margin: 5px 0;
    }
    
    .property label {
        font-weight: bold;
        width: 100px;
    }
    
    .components {
        margin-top: 20px;
    }
    
    .component {
        margin-bottom: 15px;
        border: 1px solid #eee;
        border-radius: 4px;
        padding: 10px;
    }
    
    .component-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .remove-btn {
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 2px 8px;
        cursor: pointer;
    }
    
    .component-data {
        background: #f8f8f8;
        padding: 8px;
        border-radius: 4px;
        max-height: 200px;
        overflow: auto;
        font-size: 0.9em;
    }
    
    .component-header-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .add-component {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\InspectorPanel.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\SceneHierarchyEntity.svelte ---
<script>
    import { fade } from 'svelte/transition';
    import { get } from 'svelte/store';
    import { scene, selectedEntity } from '../stores/sceneStore';
    import { userStore } from '../stores/userStore';
    
    export let entity;
    export let depth = 0;
    export let expanded = true;
    
    // Toggle entity expansion state
    function toggleExpand() {
        expanded = !expanded;
    }
    
    // Get entity name from components or use default
    $: name = entity.components.Name ? entity.components.Name.value : `Entity ${entity.id.substring(0, 4)}`;
    
    // Get icon based on component types
    $: icon = '📄'; // Default icon
    if (entity.components.Mesh) {
        icon = '📦';
    } else if (entity.components.Camera) {
        icon = '📷';
    } else if (entity.components.Light) {
        icon = '💡';
    }
    
    // Check if this entity is selected
    $: isSelected = get(selectedEntity) === entity.id;
    
    // Handle entity selection
    function selectEntity() {
        selectedEntity.set(entity.id);
    }
    
    // Get user color and initials
    $: user = get(userStore).users[entity.meta.createdBy] || { id: entity.meta.createdBy, name: 'Unknown' };
    $: userInitials = user.name ? user.name.substring(0, 2) : '??';
    $: userColor = user.color || '#cccccc';
</script>

<div class="entity"
     class:selected={isSelected}
     style={`--depth: ${depth};`}
     on:click={selectEntity}
     on:contextmenu>
    <div class="entity-header">
        {#if entity.children.length > 0}
            <button class="expand-toggle" on:click|stopPropagation={toggleExpand}>
                {#if expanded}▼{:else}►{/if}
            </button>
        {:else}
            <div class="expand-spacer"></div>
        {/if}
        
        <span class="icon">{icon}</span>
        <span class="name">{name}</span>
        
        <div class="meta-info">
            <span class="user-badge" style="--user-color: {userColor}">
                {userInitials}
            </span>
            <span class="timestamp">
                {new Date(entity.meta.lastModified).toLocaleTimeString()}
            </span>
        </div>
        
        <div class="drag-handle" draggable="true" on:dragstart on:dragend>
            ⠿
        </div>
    </div>
    
    {#if expanded}
        <div class="children" in:fade>
            {#each entity.children as childId (childId)}
                {#if $scene.entities[childId]}
                    <SceneHierarchyEntity
                        entity={$scene.entities[childId]}
                        depth={depth + 1}
                        bind:expanded
                        on:contextmenu
                        on:dragstart
                        on:dragend
                        on:drop
                        on:dragover />
                {/if}
            {/each}
        </div>
    {/if}
</div>

<style>
    .entity {
        padding-left: calc(var(--depth) * 16px);
        border-left: 1px solid #eee;
        margin: 2px 0;
    }
    
    .entity-header {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        user-select: none;
    }
    
    .entity-header:hover {
        background-color: #f0f0f0;
    }
    
    .entity.selected .entity-header {
        background-color: #e0f0ff;
        font-weight: bold;
    }
    
    .expand-toggle, .expand-spacer {
        width: 20px;
        text-align: center;
        margin-right: 4px;
    }
    
    .icon {
        margin-right: 8px;
    }
    
    .name {
        flex-grow: 1;
    }
    
    .meta-info {
        display: flex;
        align-items: center;
        margin: 0 8px;
        font-size: 0.8em;
        opacity: 0.8;
    }
    
    .user-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: var(--user-color);
        color: #fff;
        font-size: 0.7em;
        margin-right: 4px;
    }
    
    .timestamp {
        white-space: nowrap;
    }
    
    .drag-handle {
        cursor: grab;
        opacity: 0.5;
        padding: 0 4px;
    }
    
    .drag-handle:hover {
        opacity: 1;
    }
    
    .children {
        margin-left: 16px;
        border-left: 1px dashed #eee;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\SceneHierarchyEntity.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\SceneHierarchyPanel.svelte ---
<script>
import { onMount } from 'svelte';
import { toast } from '@zerodevx/svelte-toast';
import { scene, selectedEntity, selectEntity } from '../stores/sceneStore';
import SceneHierarchyEntity from './SceneHierarchyEntity.svelte';
import { dispatchCommand } from '../stores/commandDispatcher';

let contextMenu = {
    show: false,
    x: 0,
    y: 0,
    entity: null
};


// Context menu handlers
function showContextMenu(event, entityId) {
    event.preventDefault();
    contextMenu = {
        show: true,
        x: event.clientX,
        y: event.clientY,
        entity: entityId
    };
    selectEntity(entityId);
}

function closeContextMenu() {
    contextMenu.show = false;
}

async function createEntity(parentId = null) {
    try {
        await dispatchCommand('CreateEntity', { parent: parentId });
    } catch (error) {
        toast.push(`Create entity failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
    }
}

async function deleteEntity(entityId) {
    try {
        await dispatchCommand('DeleteEntity', { entityId });
    } catch (error) {
        toast.push(`Delete failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
    }
}

async function duplicateEntity(entityId) {
    // TODO: Implement duplication
    toast.push('Duplication not implemented yet', { theme: { '--toastColor': 'orange' } });
}

// Handle drag and drop for reparenting
function handleDragStart(event, entityId) {
    event.dataTransfer.setData('text/plain', entityId);
}

async function handleDrop(event, parentId) {
    event.preventDefault();
    const entityId = event.dataTransfer.getData('text/plain');
    
    try {
        await dispatchCommand('ReparentEntity', {
            entityId,
            newParentId: parentId
        });
    } catch (error) {
        toast.push(`Reparent failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
    }
}

function handleDragOver(event) {
    event.preventDefault();
}
</script>

<div class="scene-hierarchy">
    <div class="toolbar">
        <button on:click={() => createEntity()}>Create Entity</button>
    </div>
    
    <div class="tree-view">
        {#if $scene}
            {#each Object.values($scene.entities) as entity}
                {#if !entity.parent}
                    <SceneHierarchyEntity
                        entity={entity}
                        depth={0}
                        on:select={e => selectEntity(e.detail)}
                        on:contextmenu={e => showContextMenu(e, entity.id)}
                        on:dragstart={e => handleDragStart(e, entity.id)}
                        on:drop={e => handleDrop(e, entity.id)}
                        on:dragover={handleDragOver}
                    />
                {/if}
            {/each}
        {/if}
    </div>
    
    {#if contextMenu.show}
        <div class="context-menu" style="left: {contextMenu.x}px; top: {contextMenu.y}px" on:mouseleave={closeContextMenu}>
            <div class="menu-item" on:click={() => createEntity(contextMenu.entity)}>Create Child</div>
            <div class="menu-item" on:click={() => duplicateEntity(contextMenu.entity)}>Duplicate</div>
            <div class="menu-divider"></div>
            <div class="menu-item" on:click={() => deleteEntity(contextMenu.entity)}>Delete</div>
        </div>
    {/if}
</div>

<style>
    .scene-hierarchy {
        height: 100%;
        border: 1px solid #ccc;
        padding: 10px;
        display: flex;
        flex-direction: column;
    }
    
    .toolbar {
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .tree-view {
        flex: 1;
        overflow-y: auto;
        padding-top: 10px;
    }
    
    .context-menu {
        position: fixed;
        background: white;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
    }
    
    .menu-item {
        padding: 8px 16px;
        cursor: pointer;
    }
    
    .menu-item:hover {
        background-color: #f0f0f0;
    }
    
    .menu-divider {
        height: 1px;
        background-color: #eee;
        margin: 4px 0;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\SceneHierarchyPanel.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\components\VersionHistoryViewer.svelte ---
<script>
    import { onMount } from 'svelte';
    import { invoke } from '@tauri-apps/api/tauri';
    import { toast } from '@zerodevx/svelte-toast';

    export let asset;

    let versions = [];
    let selectedVersion = null;
    let diffResult = null;
    let versionA = null;
    let versionB = null;

    // Load version history when asset changes
    $: if (asset) {
        loadVersionHistory();
    }

    async function loadVersionHistory() {
        try {
            versions = await invoke('get_asset_version_history', { assetId: asset.asset_id });
        } catch (error) {
            toast.push(`Failed to load version history: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }

    async function restoreVersion() {
        if (!selectedVersion) return;
        try {
            await invoke('restore_asset_version', {
                assetId: asset.asset_id,
                version: selectedVersion.version
            });
            toast.push(`Restored version ${selectedVersion.version}`, { theme: { '--toastColor': 'green' } });
        } catch (error) {
            toast.push(`Restore failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }

    async function previewVersion() {
        if (!selectedVersion) return;
        try {
            // This would open a preview window in a real implementation
            toast.push(`Previewing version ${selectedVersion.version}`, { theme: { '--toastColor': 'blue' } });
        } catch (error) {
            toast.push(`Preview failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }

    async function showDiff() {
        if (!versionA || !versionB) return;
        try {
            diffResult = await invoke('get_asset_version_diff', {
                assetId: asset.asset_id,
                versionA: versionA.version,
                versionB: versionB.version
            });
        } catch (error) {
            toast.push(`Diff failed: ${error.message}`, { theme: { '--toastColor': 'red' } });
        }
    }
</script>

<div class="version-history">
    <h3>Version History</h3>
    
    <div class="version-list">
        {#each versions as version (version.version)}
            <div 
                class="version-item {selectedVersion?.version === version.version ? 'selected' : ''}" 
                on:click={() => selectedVersion = version}
            >
                <div class="version-number">v{version.version}</div>
                <div class="version-date">{new Date(version.timestamp * 1000).toLocaleString()}</div>
                {#if version.author}
                    <div class="version-author">By {version.author}</div>
                {/if}
            </div>
        {/each}
    </div>
    
    <div class="actions">
        <button on:click={previewVersion} disabled={!selectedVersion}>Preview</button>
        <button on:click={restoreVersion} disabled={!selectedVersion}>Restore</button>
    </div>
    
    <div class="diff-section">
        <h4>Compare Versions</h4>
        <div class="diff-selectors">
            <select bind:value={versionA}>
                <option value={null} disabled>Select version A</option>
                {#each versions as version (version.version)}
                    <option value={version}>v{version.version}</option>
                {/each}
            </select>
            <select bind:value={versionB}>
                <option value={null} disabled>Select version B</option>
                {#each versions as version (version.version)}
                    <option value={version}>v{version.version}</option>
                {/each}
            </select>
            <button on:click={showDiff} disabled={!versionA || !versionB}>Show Diff</button>
        </div>
        
        {#if diffResult}
            <div class="diff-result">
                {#if diffResult.type === 'Text'}
                    <pre>{diffResult.content}</pre>
                {:else if diffResult.type === 'Image'}
                    <img src={`data:image/png;base64,${diffResult.content}`} alt="Visual diff" />
                {:else}
                    <p>Unsupported diff type</p>
                {/if}
            </div>
        {/if}
    </div>
</div>

<style>
    .version-history {
        padding: 10px;
    }
    
    .version-list {
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 10px;
    }
    
    .version-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
    }
    
    .version-item:hover {
        background-color: #f0f0f0;
    }
    
    .version-item.selected {
        background-color: #e0f0ff;
    }
    
    .version-number {
        font-weight: bold;
    }
    
    .version-date {
        font-size: 0.8em;
        color: #666;
    }
    
    .version-author {
        font-size: 0.8em;
        color: #444;
    }
    
    .actions {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }
    
    .diff-selectors {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .diff-result {
        border: 1px solid #ddd;
        padding: 10px;
        max-height: 300px;
        overflow: auto;
    }
    
    pre {
        white-space: pre-wrap;
    }
</style>
--- END FILE: apps\cpc-studio\src\svelte\src\editor\components\VersionHistoryViewer.svelte ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\stores\assetStore.js ---
import { writable } from 'svelte/store';
import { listen } from '@tauri-apps/api/event';

// Create writable stores for assets and lock events
export const currentPath = writable('');
export const assets = writable([]);
export const selectedAsset = writable(null);

// Function to handle asset-locked event
listen('asset-locked', (event) => {
    const { asset_id, user_id, user_name } = event.payload;
    assets.update(currentAssets =>
        currentAssets.map(asset =>
            asset.id === asset_id
                ? {...asset, lock_info: { user_id, user_name }}
                : asset
        )
    );
});

// Function to handle asset-unlocked event
listen('asset-unlocked', (event) => {
    const { asset_id } = event.payload;
    assets.update(currentAssets =>
        currentAssets.map(asset =>
            asset.id === asset_id
                ? {...asset, lock_info: null}
                : asset
        )
    );
});
--- END FILE: apps\cpc-studio\src\svelte\src\editor\stores\assetStore.js ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\stores\commandDispatcher.js ---
import { invoke } from '@tauri-apps/api/tauri';

/**
 * Dispatches a command to the backend and handles the response
 * @param {string} commandName - The name of the command to execute
 * @param {Object} args - Arguments to pass to the command
 * @returns {Promise<Object>} The parsed JSON result from the command
 */
export async function dispatchCommand(commandName, args) {
    try {
        const result = await invoke('dispatch_command', {
            command: commandName,
            args: JSON.stringify(args)
        });
        return JSON.parse(result);
    } catch (error) {
        console.error(`Command ${commandName} failed:`, error);
        throw error;
    }
}
--- END FILE: apps\cpc-studio\src\svelte\src\editor\stores\commandDispatcher.js ---


--- START FILE: apps\cpc-studio\src\svelte\src\editor\stores\sceneStore.js ---
import { writable, derived } from 'svelte/store';
import { listen } from '@tauri-apps/api/event';

// Create writable stores for scene data
import { v4 as uuidv4 } from 'uuid';
import { userStore } from './userStore';

export const scene = writable({
    entities: {},
    rootEntities: [],
    locks: {},
    versionVector: {}
});

export const selectedEntity = writable(null);

// Handle entity lock events
listen('entity-locked', (event) => {
    const { entity_id, user_id, user_name } = event.payload;
    scene.update(currentScene => ({
        ...currentScene,
        locks: {
            ...currentScene.locks,
            [entity_id]: { user_id, user_name }
        }
    }));
});

// Handle entity unlock events
listen('entity-unlocked', (event) => {
    const { entity_id } = event.payload;
    scene.update(currentScene => {
        const locks = { ...currentScene.locks };
        delete locks[entity_id];
        return {
            ...currentScene,
            locks
        };
    });
});

// Function to add a new entity
export function addEntity(entityId, parentId = null) {
    scene.update(currentScene => {
        // Create new entity
        const { currentUser } = get(userStore);
        const now = new Date().toISOString();
        
        const newEntity = {
            id: entityId,
            name: `Entity ${entityId.substring(0, 4)}`,
            components: {},
            meta: {
                createdBy: currentUser.id,
                createdAt: now,
                lastModified: now,
                version: 1
            },
            children: [],
            parent: parentId
        };
        
        // Add to entities map
        const entities = {
            ...currentScene.entities,
            [entityId]: newEntity
        };
        
        // Update hierarchy
        let rootEntities = [...currentScene.rootEntities];
        if (parentId) {
            // Add as child to parent
            const parent = entities[parentId];
            if (parent) {
                entities[parentId] = {
                    ...parent,
                    children: [...(parent.children || []), entityId]
                };
            }
        } else {
            // Add to root entities
            rootEntities = [...rootEntities, entityId];
        }
        
        // Update version vector
        const versionVector = { ...currentScene.versionVector };
        versionVector[entityId] = 1;
        
        return {
            ...currentScene,
            entities,
            rootEntities,
            versionVector
        };
    });
}

// Function to remove an entity
export function removeEntity(entityId) {
    scene.update(currentScene => {
        const entities = { ...currentScene.entities };
        const rootEntities = [...currentScene.rootEntities];
        
        // Remove from parent's children or root entities
        const entity = entities[entityId];
        if (entity) {
            // Remove from parent if exists
            if (entity.parent) {
                const parent = entities[entity.parent];
                if (parent) {
                    entities[entity.parent] = {
                        ...parent,
                        children: parent.children.filter(id => id !== entityId)
                    };
                }
            } else {
                // Remove from root entities
                const index = rootEntities.indexOf(entityId);
                if (index !== -1) {
                    rootEntities.splice(index, 1);
                }
            }
            
            // Remove the entity itself
            delete entities[entityId];
        }
        
        return {
            ...currentScene,
            entities,
            rootEntities
        };
    });
}

// Function to reparent an entity
export function reparentEntity(entityId, newParentId) {
    scene.update(currentScene => {
        const entities = { ...currentScene.entities };
        const rootEntities = [...currentScene.rootEntities];
        const entity = entities[entityId];
        
        if (!entity) return currentScene;
        
        // Conflict detection
        const remoteVersion = currentScene.versionVector[entityId] || 0;
        if (entity.meta.version !== remoteVersion) {
            console.warn(`Conflict detected for entity ${entityId}. Local version: ${entity.meta.version}, Remote version: ${remoteVersion}`);
            // Resolve conflict by merging changes or prompting user
            // For now, just update to remote version
            entities[entityId] = { ...entity, ...currentScene.entities[entityId] };
            return currentScene;
        }
        
        // Remove from current parent
        if (entity.parent) {
            const oldParent = entities[entity.parent];
            if (oldParent) {
                entities[entity.parent] = {
                    ...oldParent,
                    children: oldParent.children.filter(id => id !== entityId)
                };
            }
        } else {
            // Remove from root entities
            const index = rootEntities.indexOf(entityId);
            if (index !== -1) {
                rootEntities.splice(index, 1);
            }
        }
        
        // Add to new parent
        if (newParentId) {
            const newParent = entities[newParentId];
            if (newParent) {
                entities[newParentId] = {
                    ...newParent,
                    children: [...(newParent.children || []), entityId]
                };
            }
            // Update entity's parent reference and metadata
            entities[entityId] = {
                ...entity,
                parent: newParentId,
                meta: {
                    ...entity.meta,
                    lastModified: new Date().toISOString(),
                    version: entity.meta.version + 1
                }
            };
        } else {
            // Add to root entities
            rootEntities.push(entityId);
            // Update entity's parent reference and metadata
            entities[entityId] = {
                ...entity,
                parent: null,
                meta: {
                    ...entity.meta,
                    lastModified: new Date().toISOString(),
                    version: entity.meta.version + 1
                }
            };
        }
        
        // Update version vector
        const versionVector = { ...currentScene.versionVector };
        versionVector[entityId] = entities[entityId].meta.version;
        
        return {
            ...currentScene,
            entities,
            rootEntities,
            versionVector
        };
    });
}

// Function to select an entity
export function selectEntity(entityId) {
    selectedEntity.set(entityId);
}

// Get the currently selected entity
export const selectedEntityData = derived(
    [scene, selectedEntity],
    ([$scene, $selectedEntity]) => {
        if (!$selectedEntity || !$scene.entities[$selectedEntity]) {
            return null;
        }
        return $scene.entities[$selectedEntity];
    }
);
--- END FILE: apps\cpc-studio\src\svelte\src\editor\stores\sceneStore.js ---


--- START FILE: apps\cpc-studio\src\svelte\src\styles\collaboration.scss ---
.collaboration-ui {
    .user-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: var(--user-color);
        color: #fff;
        font-size: 0.7em;
        margin-right: 4px;
    }

    .timestamp {
        font-size: 0.8em;
        opacity: 0.7;
        white-space: nowrap;
    }

    .conflict-warning {
        color: #ff6b6b;
        margin-left: 4px;
        font-size: 0.9em;
    }

    .version-indicator {
        font-size: 0.7em;
        background-color: #e0e0e0;
        border-radius: 3px;
        padding: 0 4px;
        margin-left: 4px;
    }
}
--- END FILE: apps\cpc-studio\src\svelte\src\styles\collaboration.scss ---


--- START FILE: apps\cpc-studio\src\svelte\src\styles\main.scss ---
// Main stylesheet that imports all other styles
@import 'variables';
@import 'mixins';
@import 'base';
@import 'layout';
@import 'components';
@import 'utilities';
@import 'collaboration';
--- END FILE: apps\cpc-studio\src\svelte\src\styles\main.scss ---


--- START FILE: apps\cpc-studio\src-tauri\Cargo.toml ---
[package]
name = "cpc-studio"
version = "0.1.0"
edition = "2021"

[dependencies]
tauri = { version = "1.4", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bevy = "0.9"
image = "0.24.6"
base64 = "0.21.5"
--- END FILE: apps\cpc-studio\src-tauri\Cargo.toml ---


--- START FILE: apps\cpc-studio\src-tauri\src\main.rs ---
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod asset_commands;
mod editor_core;
mod scene_commands;

use editor_core::{EditorCore, EditorState};
use tauri::Manager;
use cpc_core::p2p::NetworkHandler;
use std::sync::{Arc, Mutex};
use editor_core::scene::manager::SceneManager;

fn main() {
    tauri::Builder::default()
        .setup(|app| {
            // Create network handler
            let config = r#"{ "bootstrap_node": "/ip4/127.0.0.1/tcp/8080" }"#.to_string();
            let network_handler = NetworkHandler::get_instance(config);
            network_handler.start();
            
            // Create editor core with network handler
            let editor_core = EditorCore::new(Arc::new(network_handler.clone()));
            
            // Create editor state
            let editor_state = EditorState::default();
            
            // Create scene manager
            let scene_manager = Arc::new(Mutex::new(SceneManager::new()));
            
            // Manage state
            app.manage(network_handler.clone());
            app.manage(editor_core);
            app.manage(editor_state);
            app.manage(scene_manager);
            
            // Initialize asset manager
            let asset_manager = AssetManager::new(network_handler.clone());
            app.manage(asset_manager);
            
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            editor_core::load_project,
            editor_core::save_project,
            editor_core::create_entity,
            editor_core::delete_entity,
            editor_core::get_editor_state,
            asset_commands::get_assets_in_path,
            asset_commands::import_asset,
            asset_commands::acquire_asset_lock,
            scene_commands::update_component,
            scene_commands::add_component,
            scene_commands::remove_component,
            scene_commands::undo,
            scene_commands::redo
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
--- END FILE: apps\cpc-studio\src-tauri\src\main.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\commands\asset_commands.rs ---
use crate::error::CommandError;
use tauri::command;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct AssetMetadata {
    pub id: String,
    pub name: String,
    pub path: String,
    pub asset_type: String,
    pub thumbnail_url: Option<String>,
    pub lock_info: Option<LockInfo>,
    pub tags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LockInfo {
    pub user_id: String,
    pub user_name: String,
}

#[command]
pub async fn get_assets_in_path(path: String) -> Result<Vec<AssetMetadata>, CommandError> {
    // TODO: Implement actual asset retrieval from database/storage
    // For now, return mock data
    Ok(vec![
        AssetMetadata {
            id: "1".to_string(),
            name: "Texture".to_string(),
            path: path.clone(),
            asset_type: "image".to_string(),
            thumbnail_url: Some("/thumbnails/texture.webp".to_string()),
            lock_info: None,
            tags: vec!["material".to_string()],
        },
        AssetMetadata {
            id: "2".to_string(),
            name: "Character Model".to_string(),
            path: path.clone(),
            asset_type: "model".to_string(),
            thumbnail_url: Some("/thumbnails/character.webp".to_string()),
            lock_info: Some(LockInfo {
                user_id: "user2".to_string(),
                user_name: "Alice".to_string(),
            }),
            tags: vec!["character".to_string(), "3d".to_string()],
        },
        AssetMetadata {
            id: "3".to_string(),
            name: "Background Music".to_string(),
            path: path.clone(),
            asset_type: "audio".to_string(),
            thumbnail_url: None,
            lock_info: None,
            tags: vec!["sound".to_string(), "music".to_string()],
        },
    ])
}

#[command]
pub async fn import_asset(file_path: String, target_path: String) -> Result<(), CommandError> {
    // TODO: Implement actual asset import logic
    // For now, just log the operation
    println!("Importing asset from {} to {}", file_path, target_path);
    Ok(())
}

#[command]
pub async fn acquire_asset_lock(asset_id: String) -> Result<(), CommandError> {
    // TODO: Implement actual asset locking logic
    println!("Acquiring lock for asset {}", asset_id);
    Ok(())
}
--- END FILE: apps\cpc-studio\src-tauri\src\commands\asset_commands.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\commands\scene_commands.rs ---
use tauri::State;
use std::sync::{Arc, Mutex};
use crate::editor_core::scene::manager::SceneManager;
use crate::editor_core::scene::command::{UpdateComponentCommand, AddComponentCommand, RemoveComponentCommand};
use uuid::Uuid;
use serde_json::Value;

#[tauri::command]
pub fn update_component(
    entity_id: Uuid,
    component_type_name: String,
    new_value: Value,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<(), String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    
    // Get the old value for undo operation
    let old_value = scene_manager.get_entity(entity_id)
        .and_then(|e| e.components.get(&component_type_name).cloned())
        .unwrap_or(Value::Null);

    let command = Box::new(UpdateComponentCommand {
        entity_id,
        component_type_name,
        old_value,
        new_value,
    });

    scene_manager.execute_command(command);
    Ok(())
}

#[tauri::command]
pub fn add_component(
    entity_id: Uuid,
    component_type_name: String,
    component_data: Value,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<(), String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    
    let command = Box::new(AddComponentCommand {
        entity_id,
        component_type_name,
        component_data,
    });

    scene_manager.execute_command(command);
    Ok(())
}

#[tauri::command]
pub fn remove_component(
    entity_id: Uuid,
    component_type_name: String,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<(), String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    
    // Get current value for undo operation
    let current_value = scene_manager.get_entity(entity_id)
        .and_then(|e| e.components.get(&component_type_name).cloned())
        .unwrap_or(Value::Null);

    let command = Box::new(RemoveComponentCommand {
        entity_id,
        component_type_name,
        removed_component_data: current_value,
    });

    scene_manager.execute_command(command);
    Ok(())
}

#[tauri::command]
pub fn undo(scene_manager_state: State<Arc<Mutex<SceneManager>>>) -> Result<(), String> {
    scene_manager_state.lock().unwrap().undo();
    Ok(())
}

#[tauri::command]
pub fn redo(scene_manager_state: State<Arc<Mutex<SceneManager>>>) -> Result<(), String> {
    scene_manager_state.lock().unwrap().redo();
    Ok(())
}

#[tauri::command]
pub fn create_entity(
    parent_id: Option<Uuid>,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<Uuid, String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    let entity_id = Uuid::new_v7();
    
    let command = Box::new(CreateEntityCommand {
        entity_id,
        parent_id,
        initial_components: ComponentStorage::new(),
    });
    
    scene_manager.execute_command(command);
    Ok(entity_id)
}

#[tauri::command]
pub fn delete_entities(
    entity_ids: Vec<Uuid>,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<(), String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    
    // Capture current state for undo
    let deleted_entities: Vec<_> = entity_ids.iter()
        .filter_map(|id| scene_manager.hierarchy.entities.get(id).cloned())
        .collect();
        
    let parent_child_pairs: Vec<_> = scene_manager.hierarchy.parent_child_pairs
        .iter()
        .filter(|(p, c)| entity_ids.contains(p) || entity_ids.contains(c))
        .cloned()
        .collect();

    let command = Box::new(DeleteEntitiesCommand {
        entities: entity_ids.clone(),
        deleted_entities,
        parent_child_pairs,
    });
    
    scene_manager.execute_command(command);
    Ok(())
}

#[tauri::command]
pub fn reparent_entities(
    entity_ids: Vec<Uuid>,
    new_parent_id: Option<Uuid>,
    scene_manager_state: State<Arc<Mutex<SceneManager>>>
) -> Result<(), String> {
    let mut scene_manager = scene_manager_state.lock().unwrap();
    
    // Capture current parent states for undo
    let old_parents: Vec<_> = entity_ids.iter()
        .map(|id| scene_manager.hierarchy.entities.get(id).and_then(|e| e.parent))
        .collect();

    let command = Box::new(ReparentEntitiesCommand {
        entities: entity_ids,
        new_parent_id,
        old_parents,
    });
    
    scene_manager.execute_command(command);
    Ok(())
}
--- END FILE: apps\cpc-studio\src-tauri\src\commands\scene_commands.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\assets.rs ---
use uuid::Uuid;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use std::path::PathBuf;
use crate::cpc_core::{PeerId, VectorClock};

/// Core asset metadata structure with CRDT capabilities
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AssetMetadata {
    pub asset_id: Uuid,
    pub name: String,
    pub path: PathBuf,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbnail_path: Option<PathBuf>,
    pub asset_type: AssetType,
    pub version: u64,
    pub vector_clock: BTreeMap<PeerId, u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lock_info: Option<LockInfo>,
    #[serde(flatten)]
    pub type_specific: TypeSpecificMetadata,
}

/// Categorization of asset types with type-specific properties
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum AssetType {
    Texture,
    Model,
    Audio,
    Script,
    Prefab,
}

impl AssetType {
    /// Returns true if this asset type supports thumbnail generation
    pub fn supports_thumbnail(&self) -> bool {
        match self {
            AssetType::Texture => true,
            AssetType::Model => true,
            _ => false,
        }
    }
}

/// Type-specific metadata properties using flattened enum
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(tag = "type")]
pub enum TypeSpecificMetadata {
    Texture {
        format: String,
        srgb: bool,
        generate_mips: bool,
        compression: TextureCompression,
    },
    Model {
        import_materials: bool,
        lod_levels: u8,
        collision_type: CollisionType,
    },
    Audio {
        streaming: bool,
        quality: AudioQuality,
    },
    Script {
        entry_point: String,
    },
    Prefab {
        component_count: usize,
    },
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum TextureCompression {
    None,
    Bc7,
    Etc2,
    Astc,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum CollisionType {
    None,
    ConvexHull,
    Mesh,
    Primitive,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum AudioQuality {
    Low,
    Medium,
    High,
}

/// Information about an asset lock
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LockInfo {
    pub user_id: Uuid,
    pub user_name: String,
}

/// Error type for asset operations
#[derive(Debug, thiserror::Error)]
pub enum AssetError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("UUID parse error: {0}")]
    Uuid(#[from] uuid::Error),
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("Asset not found: {0}")]
    NotFound(Uuid),
    #[error("Network event failed: {0}")]
    NetworkEventFailed(String),
    #[error("Asset is locked by {0}")]
    Locked(String),
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\assets.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_processor.rs ---
use super::assets::{AssetMetadata, AssetType};
use anyhow::{Context, Result};
use bevy::{
    prelude::*,
    render::{
        camera::RenderTarget,
        render_resource::{
            Extent3d, TextureDescriptor, TextureDimension, TextureFormat, TextureUsages,
        },
        texture::Image,
        view::RenderLayers,
    },
    window::WindowPlugin,
};
use crossbeam_channel::{bounded, Receiver};
use image::{DynamicImage, ImageBuffer, Rgba};
use std::{
    path::PathBuf,
    sync::{Arc, Mutex},
    time::Duration,
};
use tokio::time::timeout;

/// Generates a thumbnail for the given asset
pub async fn generate_thumbnail(metadata: &AssetMetadata) -> Result<PathBuf> {
    // Create thumbnail directory if it doesn't exist
    let thumb_dir = PathBuf::from("assets/thumbnails");
    tokio::fs::create_dir_all(&thumb_dir)
        .await
        .context("Failed to create thumbnail directory")?;

    // Define output path
    let thumb_path = thumb_dir.join(format!("{}.png", metadata.asset_id));

    match metadata.asset_type {
        AssetType::Texture => {
            tokio::task::spawn_blocking({
                let path = metadata.path.clone();
                let thumb_path = thumb_path.clone();
                move || {
                    // Load and resize image
                    let img = ImageReader::open(&path)
                        .context("Failed to open image")?
                        .decode()
                        .context("Failed to decode image")?;
                    
                    let thumbnail = img.thumbnail(128, 128);
                    
                    // Save as PNG
                    thumbnail.save(&thumb_path)
                        .context("Failed to save thumbnail")?;
                    
                    Ok::<_, anyhow::Error>(())
                }
                
                /// Renders a 3D model to a PNG thumbnail using headless Bevy
                async fn render_model_headless(model_path: &PathBuf, output_path: &PathBuf) -> Result<()> {
                    // Channel to receive the rendered image
                    let (sender, receiver) = bounded(1);
                    let receiver = Arc::new(Mutex::new(receiver));
                
                    // Run Bevy app in a blocking thread
                    let model_path = model_path.clone();
                    let output_path = output_path.clone();
                    let handle = std::thread::spawn(move || {
                        let mut app = App::new();
                
                        // Minimal plugins needed for headless rendering
                        app.add_plugins(MinimalPlugins);
                        app.add_plugin(AssetPlugin::default());
                        app.add_plugin(bevy::render::RenderPlugin::default());
                        app.add_plugin(bevy::window::WindowPlugin {
                            primary_window: None,
                            exit_condition: bevy::window::ExitCondition::DontExit,
                            close_when_requested: false,
                        });
                        app.add_plugin(bevy::core::CorePlugin::default());
                        app.add_plugin(bevy::scene::ScenePlugin);
                        app.add_plugin(bevy_gltf::GltfPlugin);
                
                        // Create render texture
                        let size = Extent3d {
                            width: 256,
                            height: 256,
                            ..default()
                        };
                
                        let mut image = Image {
                            texture_descriptor: TextureDescriptor {
                                label: None,
                                size,
                                dimension: TextureDimension::D2,
                                format: TextureFormat::Rgba8UnormSrgb,
                                mip_level_count: 1,
                                sample_count: 1,
                                usage: TextureUsages::RENDER_ATTACHMENT | TextureUsages::COPY_SRC,
                                view_formats: &[],
                            },
                            ..default()
                        };
                
                        // Fill image data with transparent pixels
                        image.resize(size);
                
                        let image_handle = app.world.spawn(image).id();
                        let images = &mut app.world.resource_mut::<Assets<Image>>();
                        let image_handle = images.add(image);
                
                        // Camera
                        let camera = Camera3dBundle {
                            camera: Camera {
                                target: RenderTarget::Image(image_handle.clone()),
                                ..default()
                            },
                            transform: Transform::from_xyz(2.0, 2.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
                            ..default()
                        };
                        app.world.spawn(camera).insert(RenderLayers::layer(1));
                
                        // Light
                        app.world.spawn(DirectionalLightBundle {
                            directional_light: DirectionalLight {
                                illuminance: 1000.0,
                                ..default()
                            },
                            transform: Transform::from_xyz(4.0, 7.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
                            ..default()
                        });
                
                        // Load model
                        let asset_server = app.world.resource::<AssetServer>();
                        let model_handle: Handle<Gltf> = asset_server.load(model_path);
                
                        // System to spawn model once loaded
                        app.add_system(move |mut commands: Commands, models: Res<Assets<Gltf>>| {
                            if let Some(model) = models.get(&model_handle) {
                                // Spawn the first scene in the GLTF
                                if let Some(scene) = model.scenes.first() {
                                    commands.spawn(SceneBundle {
                                        scene: scene.clone(),
                                        ..default()
                                    });
                                }
                            }
                        });
                
                        // System to capture rendered image
                        app.add_system(move |images: Res<Assets<Image>>| {
                            if let Some(image) = images.get(&image_handle) {
                                if image.data.len() >= 4 * 256 * 256 {
                                    let _ = sender.send(image.data.clone());
                                }
                            }
                        });
                
                        // Run the app for a few frames to load and render
                        for _ in 0..10 {
                            app.update();
                        }
                    });
                
                    // Wait for rendering to complete with timeout
                    let render_result = timeout(Duration::from_secs(5), async {
                        let receiver = receiver.lock().unwrap();
                        receiver.recv().map_err(|_| anyhow::anyhow!("Render failed"))
                    })
                    .await;
                
                    // Join the Bevy thread
                    handle.join().map_err(|_| anyhow::anyhow!("Bevy thread panicked"))?;
                
                    // Process the rendered image
                    let image_data = render_result??;
                    let image_buffer = ImageBuffer::<Rgba<u8>, _>::from_raw(256, 256, image_data)
                        .ok_or_else(|| anyhow::anyhow!("Invalid image dimensions"))?;
                
                    let dynamic_image = DynamicImage::ImageRgba8(image_buffer);
                    dynamic_image
                        .save(output_path)
                        .context("Failed to save rendered thumbnail")?;
                
                    Ok(())
                }
            })
            .await??;
        }
        AssetType::Model => {
            // Use headless Bevy rendering for models
            render_model_headless(&metadata.path, &thumb_path).await?;
        }
        _ => {
            // Return error for unsupported asset types
            anyhow::bail!(
                "Thumbnail generation not supported for {:?} assets",
                metadata.asset_type
            )
        }
    }

    Ok(thumb_path)
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_processor.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\bevy_plugin.rs ---
use bevy::prelude::*;
use bevy::render::camera::RenderTarget;
use bevy::render::render_resource::{
    Extent3d, TextureDescriptor, TextureDimension, TextureFormat, TextureUsages,
};
use bevy::window::WindowId;
use std::sync::{Arc, Mutex};
use wry::webview::WebView;
use crate::event_bridge::{NetworkEventBridge, editor_event_to_p2p, p2p_event_to_editor};
use cpc_core::p2p::NetworkHandler;
use image;
use base64::{self, engine::general_purpose::STANDARD};
use crate::editor_core::scene::hierarchy::SceneHierarchy;

pub struct EditorBevyPlugin {
    pub webview: Arc<Mutex<Option<WebView>>>,
    pub network_handler: Arc<NetworkHandler>,
}

impl Plugin for EditorBevyPlugin {
    fn build(&self, app: &mut App) {
        // Create network event bridge
        let device_id = "editor_device"; // In production would use actual device ID
        let bridge = NetworkEventBridge::new(self.network_handler.clone(), device_id);
        
        // Create asset manager
        let asset_manager = AssetManager::new(self.network_handler.clone());
        
        // Create scene hierarchy
        let scene_hierarchy = SceneHierarchy::default();
        
        app.insert_resource(EditorTextureResource::default())
            .insert_resource(bridge)
            .insert_resource(asset_manager)
            .insert_resource(scene_hierarchy)
            .add_event::<crate::event_bridge::EditorEvent>()
            .add_event::<crate::event_bridge::EditorCommand>()
            .add_startup_system(setup_editor_camera)
            .add_system(update_texture)
            .add_system(editor_event_to_p2p)
            .add_system(p2p_event_to_editor)
            .add_system(update_scene_hierarchy);
        
        // Setup asset manager systems
        app.resource::<AssetManager>().setup_bevy(app);
    }
}

/// System to update scene hierarchy transforms
fn update_scene_hierarchy(mut scene_hierarchy: ResMut<SceneHierarchy>) {
    scene_hierarchy.update_transforms();
}

#[derive(Default)]
pub struct EditorTextureResource {
    pub texture: Option<Handle<Image>>,
}

fn setup_editor_camera(
    mut commands: Commands,
    mut images: ResMut<Assets<Image>>,
    mut editor_texture: ResMut<EditorTextureResource>,
) {
    // Create texture for offscreen rendering
    let size = Extent3d {
        width: 800,
        height: 600,
        depth_or_array_layers: 1,
    };

    let mut image = Image {
        texture_descriptor: TextureDescriptor {
            label: Some("editor_texture"),
            size,
            dimension: TextureDimension::D2,
            format: TextureFormat::Bgra8UnormSrgb,
            mip_level_count: 1,
            sample_count: 1,
            usage: TextureUsages::RENDER_ATTACHMENT | TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        },
        ..Default::default()
    };

    // Fill image data with placeholder
    image.resize(size);

    let image_handle = images.add(image);
    editor_texture.texture = Some(image_handle.clone());

    // Create camera that renders to texture
    commands.spawn(Camera2dBundle {
        camera: Camera {
            target: RenderTarget::Image(image_handle),
            ..default()
        },
        ..default()
    });
fn image_to_png(image: &Image) -> Result<Vec<u8>, image::ImageError> {
    let size = image.texture_descriptor.size;
    let data = image.data.as_slice();

    // Check the length
    if data.len() != (size.width * size.height * 4) as usize {
        return Err(image::ImageError::Parameter(image::error::ParameterError::from_kind(
            image::error::ParameterErrorKind::DimensionMismatch,
        )));
    }

    // Convert BGRA to RGBA
    let mut rgba_data = Vec::with_capacity(data.len());
    for i in (0..data.len()).step_by(4) {
        rgba_data.push(data[i + 2]); // R
        rgba_data.push(data[i + 1]); // G
        rgba_data.push(data[i]);     // B
        rgba_data.push(data[i + 3]); // A
    }

    let img_buffer = image::ImageBuffer::from_vec(size.width, size.height, rgba_data)
        .ok_or_else(|| image::ImageError::Parameter(image::error::ParameterError::from_kind(
            image::error::ParameterErrorKind::DimensionMismatch,
        )))?;

    let mut png_data = Vec::new();
    let encoder = image::codecs::png::PngEncoder::new(&mut png_data);
    encoder.encode(
        &img_buffer,
        size.width,
        size.height,
        image::ColorType::Rgba8,
    )?;

    Ok(png_data)
}

fn update_texture(
    webview: Res<Arc<Mutex<Option<WebView>>>>,
    editor_texture: Res<EditorTextureResource>,
    images: Res<Assets<Image>>,
) {
    if let Some(webview) = webview.lock().unwrap().as_ref() {
        if let Some(texture_handle) = &editor_texture.texture {
            if let Some(image) = images.get(texture_handle) {
                match image_to_png(image) {
                    Ok(png_data) => {
                        let base64 = STANDARD.encode(&png_data);
                        let js = format!(
                            "window.dispatchEvent(new CustomEvent('texture-update', {{ detail: '{}' }}));",
                            base64
                        );
                        if let Err(e) = webview.evaluate_script(&js) {
                            eprintln!("Failed to evaluate script: {}", e);
                        }
                    }
                    Err(e) => eprintln!("Failed to convert image to PNG: {}", e),
                }
            }
        }
    }
}
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\bevy_plugin.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\collaboration.rs ---
use bevy::prelude::*;
use cpc_core::p2p::NetworkHandler;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Component)]
pub struct Collaborator {
    pub peer_id: String,
    pub color: Color,
    pub cursor_position: Vec2,
    pub selection_range: Option<(Vec2, Vec2)>,
    pub has_conflict: bool,
}

#[derive(Resource)]
pub struct Collaborators {
    pub local_peer_id: String,
    pub collaborators: HashMap<String, Entity>,
    pub color_map: HashMap<String, Color>,
}

impl Collaborators {
    pub fn new(local_peer_id: &str) -> Self {
        Collaborators {
            local_peer_id: local_peer_id.to_string(),
            collaborators: HashMap::new(),
            color_map: HashMap::new(),
        }
    }

    pub fn get_or_create_color(&mut self, peer_id: &str) -> Color {
        if let Some(color) = self.color_map.get(peer_id) {
            return *color;
        }

        // Generate distinct color based on peer ID hash
        let hash = peer_id.chars().fold(0, |acc, c| acc * 31 + c as u32);
        let r = ((hash >> 16) & 0xFF) as f32 / 255.0;
        let g = ((hash >> 8) & 0xFF) as f32 / 255.0;
        let b = (hash & 0xFF) as f32 / 255.0;
        
        let color = Color::rgb(r, g, b);
        self.color_map.insert(peer_id.to_string(), color);
        color
    }
}

pub fn add_collaborator(
    mut commands: Commands,
    mut collaborators: ResMut<Collaborators>,
    peer_id: String,
) {
    if peer_id == collaborators.local_peer_id {
        return; // Skip local peer
    }

    let color = collaborators.get_or_create_color(&peer_id);
    let entity = commands.spawn((
        Collaborator {
            peer_id: peer_id.clone(),
            color,
            cursor_position: Vec2::ZERO,
            selection_range: None,
            has_conflict: false,
        },
        Name::new(format!("Collaborator: {}", peer_id)),
    )).id();

    collaborators.collaborators.insert(peer_id, entity);
}

pub fn remove_collaborator(
    mut commands: Commands,
    mut collaborators: ResMut<Collaborators>,
    peer_id: String,
) {
    if let Some(entity) = collaborators.collaborators.remove(&peer_id) {
        commands.entity(entity).despawn();
    }
}

pub fn update_collaborator_position(
    mut collaborators: ResMut<Collaborators>,
    mut cursor_events: EventReader<CursorMovedEvent>,
    network_handler: Res<Arc<NetworkHandler>>,
) {
    for event in cursor_events.iter() {
        // Update local collaborator position
        if let Some(entity) = collaborators.collaborators.get(&collaborators.local_peer_id) {
            if let Some(mut collaborator) = collaborators.get_mut(*entity) {
                collaborator.cursor_position = event.position;
            }
        }

        // Broadcast cursor position to peers
        let payload = bincode::serialize(&event.position).unwrap();
        network_handler.broadcast_event(
            &P2PEvent::new(
                Uuid::new_v4().to_string(),
                EventType::CursorPosition,
                collaborators.local_peer_id.clone(),
                payload,
            ),
            1, // High priority for cursor events
        );
    }
}

pub fn handle_remote_cursor_position(
    mut collaborators: ResMut<Collaborators>,
    mut network_events: EventReader<P2PEvent>,
) {
    for event in network_events.iter() {
        if event.event_type != EventType::CursorPosition {
            continue;
        }

        if let Ok(position) = bincode::deserialize::<Vec2>(&event.payload) {
            if let Some(entity) = collaborators.collaborators.get(&event.source_device) {
                if let Some(mut collaborator) = collaborators.get_mut(*entity) {
                    collaborator.cursor_position = position;
                }
            }
        }
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\collaboration.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\events.rs ---
use bevy::prelude::*;
use super::assets::{AssetMetadata, AssetType};
use crate::cpc_core::VectorClock;

#[derive(Event, Debug, Serialize, Deserialize)]
pub enum AssetEvent {
    Created {
        metadata: AssetMetadata,
        clock: VectorClock,
    },
    MetadataUpdated {
        asset_id: uuid::Uuid,
        delta: serde_json::Value,
        clock: VectorClock,
    },
    ContentUpdated {
        asset_id: uuid::Uuid,
        content_hash: String,
        clock: VectorClock,
    },
    Deleted {
        asset_id: uuid::Uuid,
        clock: VectorClock,
    },
}

#[derive(Event)]
pub struct EditorCommand {
    pub command_type: String,
    pub data: Vec<u8>,
}

#[derive(Event)]
pub struct CursorMovedEvent {
    pub position: Vec2,
}

// Preserve existing EditorEvent for non-asset related events
#[derive(Event)]
pub struct EditorEvent {
    pub event_type: String,
    pub data: Vec<u8>,
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\events.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\event_bridge.rs ---
use bevy::prelude::*;
use cpc_core::events::{P2PEvent, EventType};
use cpc_core::p2p::NetworkHandler;
use std::sync::{Arc, Mutex};
use std::collections::BTreeMap;
use uuid::Uuid;
use crate::editor_core::events::CursorMovedEvent;

#[derive(Event)]
pub struct EditorEvent {
    pub event_type: String,
    pub data: Vec<u8>,
}

#[derive(Event)]
pub struct EditorCommand {
    pub command_type: String,
    pub data: Vec<u8>,
}

pub struct NetworkEventBridge {
    pub network_handler: Arc<NetworkHandler>,
    pub vector_clock: BTreeMap<String, u64>,
    pub device_id: String,
}

impl NetworkEventBridge {
    pub fn new(network_handler: Arc<NetworkHandler>, device_id: &str) -> Self {
        let mut vector_clock = BTreeMap::new();
        vector_clock.insert(device_id.to_string(), 0);
        
        NetworkEventBridge {
            network_handler,
            vector_clock,
            device_id: device_id.to_string(),
        }
    }

    pub fn increment_vector_clock(&mut self) {
        let counter = self.vector_clock.entry(self.device_id.clone())
            .or_insert(0);
        *counter += 1;
    }
}

pub fn editor_event_to_p2p(
    mut editor_events: EventReader<EditorEvent>,
    mut bridge: ResMut<NetworkEventBridge>,
) {
    for event in editor_events.iter() {
        bridge.increment_vector_clock();
        
        let p2p_event = P2PEvent {
            event_id: Uuid::new_v4().to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as u64,
            event_type: EventType::GameStateUpdate,
            source_device: bridge.device_id.clone(),
            payload: event.data.clone(),
            vector_clock: bridge.vector_clock.clone(),
            conflict_flag: false,
        };
        
        let serialized = serialize_event(&p2p_event);
        bridge.network_handler.broadcast_event(&serialized, 0);
    }
}

pub fn cursor_event_to_p2p(
    mut cursor_events: EventReader<CursorMovedEvent>,
    bridge: ResMut<NetworkEventBridge>,
) {
    for event in cursor_events.iter() {
        let payload = bincode::serialize(&event.position).unwrap();
        
        let p2p_event = P2PEvent {
            event_id: Uuid::new_v4().to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as u64,
            event_type: EventType::CursorPosition,
            source_device: bridge.device_id.clone(),
            payload,
            vector_clock: BTreeMap::new(), // Cursor events don't affect state
            conflict_flag: false,
        };
        
        let serialized = serialize_event(&p2p_event);
        bridge.network_handler.broadcast_event(&serialized, 1); // High priority
    }
}

pub fn p2p_event_to_editor(
    mut bridge: ResMut<NetworkEventBridge>,
    mut editor_commands: EventWriter<EditorCommand>,
) {
    let mut network_handler = bridge.network_handler.swarm.lock().unwrap();
    
    while let Some(event) = network_handler.next_event() {
        let p2p_event = deserialize_event(&event);
        
        // Handle conflict resolution using vector clocks
        let mut conflict = false;
        for (device, counter) in &p2p_event.vector_clock {
            let local_counter = bridge.vector_clock.get(device).unwrap_or(&0);
            if counter > local_counter {
                conflict = true;
                break;
            }
        }
        
        if !conflict {
            // Update vector clock
            for (device, counter) in p2p_event.vector_clock {
                bridge.vector_clock.entry(device)
                    .and_modify(|e| *e = (*e).max(counter))
                    .or_insert(counter);
            }
            
            // Convert to editor command
            editor_commands.send(EditorCommand {
                command_type: "APPLY_STATE".to_string(),
                data: p2p_event.payload,
            });
        } else {
            // Handle conflict - in production would use reconciliation protocol
            warn!("Conflict detected for event {}", p2p_event.event_id);
        }
    }
}

fn serialize_event(event: &P2PEvent) -> Vec<u8> {
    let mut buf = Vec::new();
    // Simple serialization - would use protobuf in production
    buf.extend_from_slice(event.event_id.as_bytes());
    buf.extend_from_slice(&event.timestamp.to_be_bytes());
    buf.extend_from_slice(&(event.payload.len() as u32).to_be_bytes());
    buf.extend_from_slice(&event.payload);
    buf
}

fn deserialize_event(data: &[u8]) -> P2PEvent {
    // Simple deserialization - would use protobuf in production
    let event_id = String::from_utf8(data[0..36].to_vec()).unwrap();
    let timestamp = u64::from_be_bytes(data[36..44].try_into().unwrap());
    let payload_len = u32::from_be_bytes(data[44..48].try_into().unwrap()) as usize;
    let payload = data[48..48+payload_len].to_vec();
    
    P2PEvent {
        event_id,
        timestamp,
        event_type: EventType::GameStateUpdate,
        source_device: "remote".to_string(),
        payload,
        vector_clock: BTreeMap::new(),
        conflict_flag: false,
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\event_bridge.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\lib.rs ---
pub mod tauri_integration;
pub mod bevy_plugin;
pub mod state;

pub use state::EditorState;
pub use tauri_integration::EditorCore;
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\lib.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\mod.rs ---
//! Core editor functionality shared between Tauri commands and Bevy systems

pub mod collaboration;
pub mod events;
pub mod state;
pub mod tauri_integration;
pub mod asset_processor;
pub mod assets;
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\mod.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\state.rs ---
use serde::{Serialize, Deserialize};
use std::sync::{Arc, Mutex};

#[derive(Serialize, Deserialize, Default)]
pub struct EditorState {
    pub active_scene: String,
    pub selected_entities: Vec<u32>,
    pub resources: Vec<String>,
}

impl EditorState {
    pub fn new() -> Self {
        EditorState::default()
    }
}

pub type SharedEditorState = Arc<Mutex<EditorState>>;
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\state.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\tauri_integration.rs ---
use crate::editor_core::{
    assets::{AssetError, AssetMetadata, AssetType, TypeSpecificMetadata, TextureCompression},
    state::{EditorState, SharedEditorState},
};
use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use tauri::State;
use uuid::Uuid;
use std::path::PathBuf;
use std::collections::BTreeMap;

#[derive(Default)]
pub struct EditorCore {
    pub bevy_app: App,
}

impl EditorCore {
    pub fn new() -> Self {
        let mut bevy_app = App::new();
        bevy_app.add_plugins(MinimalPlugins);
        EditorCore { bevy_app }
    }
}

/// Unified error handling for Tauri commands
#[derive(Debug, thiserror::Error, Serialize)]
pub enum CommandError {
    #[error("Asset error: {0}")]
    Asset(#[from] AssetError),
    #[error("State lock error")]
    StateLock,
    #[error("Serialization error: {0}")]
    Serialization(String),
}

impl From<serde_json::Error> for CommandError {
    fn from(e: serde_json::Error) -> Self {
        CommandError::Serialization(e.to_string())
    }
}

#[tauri::command]
#[tauri::command]
pub async fn import_asset(
    state: State<'_, SharedEditorState>,
    path: String,
) -> Result<Uuid, CommandError> {
    let path_buf = PathBuf::from(&path);
    let asset_type = detect_asset_type(&path);
    let mut metadata = AssetMetadata {
        asset_id: Uuid::new_v4(),
        name: path_buf.file_name().unwrap().to_string_lossy().to_string(),
        path: path_buf.clone(),
        thumbnail_path: None,
        asset_type,
        version: 1,
        vector_clock: BTreeMap::new(), // TODO: Initialize with local peer
        type_specific: TypeSpecificMetadata::default_for_type(asset_type),
    };

    // Generate thumbnail for supported asset types
    if asset_type.supports_thumbnail() {
        match asset_processor::generate_thumbnail(&metadata).await {
            Ok(thumb_path) => {
                println!("Thumbnail generated at: {:?}", thumb_path);
                metadata.thumbnail_path = Some(thumb_path);
            }
            Err(e) => {
                eprintln!("Failed to generate thumbnail for asset {}: {}", metadata.asset_id, e);
                // Fallback to default icon
                metadata.thumbnail_path = Some(PathBuf::from("assets/default_icon.png"));
            }
        }
    }

    // Lock state only when needed
    let mut state = state.lock().map_err(|_| CommandError::StateLock)?;
    
    // TODO: Send to reconciliation engine
    // state.reconciliation_engine.handle_event(...);
    
    // TEMPORARY: Print metadata for verification
    println!("Imported asset metadata: {:?}", metadata);
    
    Ok(metadata.asset_id)
}

#[tauri::command]
pub fn get_asset_metadata(
    state: State<'_, SharedEditorState>,
    asset_id: Uuid,
) -> Result<AssetMetadata, CommandError> {
    let state = state.lock().map_err(|_| CommandError::StateLock)?;
    
    // TODO: Query reconciliation engine
    Err(AssetError::NotFound(asset_id).into())
}

// ===== Scene Hierarchy Commands =====

use crate::editor_core::scene::{Entity, SceneHierarchy};
use crate::editor_core::scene::entity_sync::EntitySync;

#[derive(Serialize)]
pub struct SceneHierarchyDTO {
    entities: HashMap<Uuid, EntityDTO>,
    parent_child_pairs: Vec<(Uuid, Uuid)>,
}

#[derive(Serialize)]
pub struct EntityDTO {
    id: Uuid,
    name: String,
    transform: TransformDTO,
}

#[derive(Serialize)]
pub struct TransformDTO {
    translation: [f32; 3],
    rotation: [f32; 4],
    scale: [f32; 3],
}

#[tauri::command]
pub fn get_scene_hierarchy(
    state: State<'_, SharedEditorState>,
) -> Result<SceneHierarchyDTO, CommandError> {
    let state = state.lock().map_err(|_| CommandError::StateLock)?;
    let hierarchy = state.bevy_app.world.get_resource::<SceneHierarchy>()
        .ok_or_else(|| CommandError::Serialization("SceneHierarchy resource not found".to_string()))?;

    let mut entities = HashMap::new();
    let mut parent_child_pairs = Vec::new();

    // Convert entities to DTOs
    for (id, entity) in &hierarchy.entities {
        entities.insert(*id, EntityDTO {
            id: *id,
            name: entity.name.clone(),
            transform: TransformDTO {
                translation: entity.transform.translation.into(),
                rotation: entity.transform.rotation.into(),
                scale: entity.transform.scale.into(),
            },
        });
    }

    // Collect parent-child relationships
    for (parent_id, children) in &hierarchy.children {
        for child_id in children {
            parent_child_pairs.push((*parent_id, *child_id));
        }
    }

    Ok(SceneHierarchyDTO { entities, parent_child_pairs })
}

#[tauri::command]
pub fn create_entity(
    state: State<'_, SharedEditorState>,
    parent: Option<Uuid>,
) -> Result<Uuid, CommandError> {
    let mut state = state.lock().map_err(|_| CommandError::StateLock)?;
    let hierarchy = state.bevy_app.world.get_resource_mut::<SceneHierarchy>()
        .ok_or_else(|| CommandError::Serialization("SceneHierarchy resource not found".to_string()))?;
    
    let entity_sync = state.bevy_app.world.get_resource_mut::<EntitySync>()
        .ok_or_else(|| CommandError::Serialization("EntitySync resource not found".to_string()))?;

    let entity_id = Uuid::new_v4();
    let entity = Entity {
        id: entity_id,
        name: format!("Entity {}", entity_id),
        parent,
        transform: Default::default(),
    };

    // Add entity to hierarchy
    hierarchy.add_entity(entity);

    // Automatically lock the new entity for the current user
    // TODO: Get current user ID and name from session
    let user_id = Uuid::new_v4();
    let user_name = "Current User".to_string();
    entity_sync.acquire_lock(entity_id, user_id, user_name)?;

    Ok(entity_id)
}

#[tauri::command]
pub fn delete_entities(
    state: State<'_, SharedEditorState>,
    ids: Vec<Uuid>,
) -> Result<(), CommandError> {
    let mut state = state.lock().map_err(|_| CommandError::StateLock)?;
    let hierarchy = state.bevy_app.world.get_resource_mut::<SceneHierarchy>()
        .ok_or_else(|| CommandError::Serialization("SceneHierarchy resource not found".to_string()))?;
    
    let entity_sync = state.bevy_app.world.get_resource_mut::<EntitySync>()
        .ok_or_else(|| CommandError::Serialization("EntitySync resource not found".to_string()))?;

    for id in ids {
        // Check lock before deletion
        if let Some(lock_info) = entity_sync.get_lock_info(id) {
            return Err(CommandError::Asset(AssetError::Locked(lock_info.user_name.clone())));
        }
        
        hierarchy.remove_entity(id);
    }

    Ok(())
}

#[tauri::command]
pub fn reparent_entities(
    state: State<'_, SharedEditorState>,
    entity_map: HashMap<Uuid, Option<Uuid>>,
) -> Result<(), CommandError> {
    let mut state = state.lock().map_err(|_| CommandError::StateLock)?;
    let hierarchy = state.bevy_app.world.get_resource_mut::<SceneHierarchy>()
        .ok_or_else(|| CommandError::Serialization("SceneHierarchy resource not found".to_string()))?;
    
    let entity_sync = state.bevy_app.world.get_resource_mut::<EntitySync>()
        .ok_or_else(|| CommandError::Serialization("EntitySync resource not found".to_string()))?;

    for (entity_id, new_parent) in entity_map {
        // Check lock before reparenting
        if let Some(lock_info) = entity_sync.get_lock_info(entity_id) {
            return Err(CommandError::Asset(AssetError::Locked(lock_info.user_name.clone())));
        }

        if let Some(parent_id) = new_parent {
            hierarchy.add_child(parent_id, entity_id);
        } else {
            // If new_parent is None, remove from current parent
            if let Some(entity) = hierarchy.get_entity_mut(&entity_id) {
                entity.parent = None;
            }
        }
    }

    Ok(())
}

// Simple asset type detection based on file extension
fn detect_asset_type(path: &str) -> AssetType {
    if path.ends_with(".png") || path.ends_with(".jpg") || path.ends_with(".jpeg") {
        AssetType::Texture
    } else if path.ends_with(".glb") || path.ends_with(".gltf") {
        AssetType::Model
    } else if path.ends_with(".wav") || path.ends_with(".mp3") {
        AssetType::Audio
    } else if path.ends_with(".rs") || path.ends_with(".js") {
        AssetType::Script
    } else if path.ends_with(".prefab") {
        AssetType::Prefab
    } else {
        AssetType::Texture // Default to texture
    }
}

impl TypeSpecificMetadata {
    pub fn default_for_type(asset_type: AssetType) -> Self {
        match asset_type {
            AssetType::Texture => TypeSpecificMetadata::Texture {
                format: "png".to_string(),
                srgb: true,
                generate_mips: true,
                compression: TextureCompression::None,
            },
            AssetType::Model => TypeSpecificMetadata::Model {
                import_materials: true,
                lod_levels: 1,
                collision_type: CollisionType::None,
            },
            AssetType::Audio => TypeSpecificMetadata::Audio {
                streaming: false,
                quality: AudioQuality::Medium,
            },
            AssetType::Script => TypeSpecificMetadata::Script {
                entry_point: "main".to_string(),
            },
            AssetType::Prefab => TypeSpecificMetadata::Prefab {
                component_count: 0,
            },
        }
    }
}

#[tauri::command]
pub fn update_asset_metadata(
    state: State<'_, SharedEditorState>,
    asset_id: Uuid,
    delta: serde_json::Value,
) -> Result<(), CommandError> {
    let mut state = state.lock().map_err(|_| CommandError::StateLock)?;
    
    // TODO: Implement metadata patching and vector clock update
    // let mut metadata = state.get_asset(asset_id)?;
    // apply_patch(&mut metadata, delta);
    // metadata.vector_clock.increment(local_peer_id);
    // send_to_reconciliation_engine(...);
    
    Ok(())
}

#[tauri::command]
pub fn get_assets_in_path(
    state: State<'_, SharedEditorState>,
    path: String,
) -> Result<Vec<AssetMetadata>, CommandError> {
    let state = state.lock().map_err(|_| CommandError::StateLock)?;
    
    // TODO: Implement proper path-based query from asset storage
    // For now, return all assets with matching path prefix
    let mut assets = Vec::new();
    // Placeholder - in real implementation this would query the asset store
    assets.push(AssetMetadata {
        asset_id: Uuid::new_v4(),
        name: "example".to_string(),
        path: PathBuf::from(&path),
        thumbnail_path: Some(PathBuf::from("assets/thumbnails/example.png")),
        asset_type: AssetType::Texture,
        version: 1,
        vector_clock: BTreeMap::new(),
        type_specific: TypeSpecificMetadata::Texture {
            format: "png".to_string(),
            srgb: true,
            generate_mips: true,
            compression: TextureCompression::None,
        },
    });
    
    Ok(assets)
}

// Existing project load/save commands remain unchanged
// ...

/// Updated asset folder structure with UUID-based identifiers
#[derive(Debug, Serialize, Deserialize)]
pub struct AssetFolder {
    pub uuid: Uuid,
    pub name: String,
    pub path: PathBuf,
    pub children: Vec<AssetFolder>,
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\tauri_integration.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_processor.rs ---
//! Asset processing pipeline with async queue

use bevy::prelude::*;
use image::{ImageFormat, ImageError};
use symphonia::core::io::MediaSourceStream;
use symphonia::core::probe::Hint;
use crate::asset_manager::asset_storage::{AssetStorage, AssetMetadata};
use sha2::{Sha256, Digest};
use std::path::Path;
use std::sync::Arc;

pub struct AssetProcessor {
    storage: Arc<AssetStorage>,
    // Queue implementation would go here
}

impl AssetProcessor {
    pub fn new(storage: Arc<AssetStorage>) -> Self {
        Self { storage }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        app.add_system(process_asset_queue);
    }

    pub fn import_asset(&self, path: &str) {
        // Add to processing queue
        // Implementation would add path to a queue
    }
}

// Placeholder for queue implementation
fn get_next_queued_asset() -> Option<PathBuf> {
    // Implementation would return next asset path from queue
    None
}

fn process_asset_queue(storage: Res<Arc<AssetStorage>>) {
    // Get next asset from processing queue
    while let Some(asset_path) = get_next_queued_asset() {
        if let Ok(metadata) = process_asset(&asset_path) {
            storage.store_metadata(&metadata);
            
            // Generate and store thumbnail if applicable
            if let Some(thumb_data) = generate_thumbnail(&asset_path, 128, 128) {
                let thumb_id = storage.store_asset(&thumb_data, "image/webp");
                storage.link_thumbnail(&metadata.id, &thumb_id);
            }
        }
    }
}

/// Process an asset file and extract metadata
fn process_asset(path: &Path) -> Result<AssetMetadata, String> {
    let data = std::fs::read(path).map_err(|e| e.to_string())?;
    let mut hasher = Sha256::new();
    hasher.update(&data);
    let hash = hex::encode(hasher.finalize());
    
    let format = get_asset_format(path);
    let metadata = match format.as_str() {
        "image/png" | "image/jpeg" | "image/webp" => {
            let img = image::open(path).map_err(|e| e.to_string())?;
            let dimensions = img.dimensions();
            AssetMetadata {
                id: hash.clone(),
                format,
                width: Some(dimensions.0 as i32),
                height: Some(dimensions.1 as i32),
                duration: None,
                // other fields...
            }
        }
        "audio/mpeg" | "audio/wav" | "audio/ogg" => {
            let duration = get_audio_duration(path)?;
            AssetMetadata {
                id: hash.clone(),
                format,
                width: None,
                height: None,
                duration: Some(duration),
                // other fields...
            }
        }
        _ => AssetMetadata {
            id: hash.clone(),
            format,
            width: None,
            height: None,
            duration: None,
            // other fields...
        }
    };
    
    Ok(metadata)
}

/// Generate thumbnail for supported image types
fn generate_thumbnail(path: &Path, width: u32, height: u32) -> Option<Vec<u8>> {
    if let Ok(img) = image::open(path) {
        let thumbnail = img.thumbnail(width, height);
        let mut buf = Vec::new();
        if thumbnail.write_to(&mut buf, ImageFormat::WebP).is_ok() {
            return Some(buf);
        }
    }
    None
}

/// Get audio duration using symphonia
fn get_audio_duration(path: &Path) -> Result<f64, String> {
    let src = std::fs::File::open(path).map_err(|e| e.to_string())?;
    let mss = MediaSourceStream::new(Box::new(src), Default::default());
    let mut hint = Hint::new();
    
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        hint.with_extension(ext);
    }
    
    let probed = symphonia::default::get_probe().format(&hint, mss, &Default::default(), &Default::default())
        .map_err(|e| e.to_string())?;
    
    if let Some(track) = probed.format.default_track() {
        if let Some(time_base) = track.codec_params.time_base {
            if let Some(n_frames) = track.codec_params.n_frames {
                return Ok(n_frames as f64 * time_base.den as f64 / time_base.num as f64);
            }
        }
    }
    
    Err("Could not determine audio duration".into())
}

/// Determine asset format from file extension
fn get_asset_format(path: &Path) -> String {
    match path.extension().and_then(|e| e.to_str()) {
        Some("png") => "image/png".into(),
        Some("jpg") | Some("jpeg") => "image/jpeg".into(),
        Some("webp") => "image/webp".into(),
        Some("mp3") => "audio/mpeg".into(),
        Some("wav") => "audio/wav".into(),
        Some("ogg") => "audio/ogg".into(),
        _ => "application/octet-stream".into(),
    }
}

/// Convert audio file to WAV format
fn convert_audio_to_wav(path: &Path) -> Result<Vec<u8>, String> {
    let src = std::fs::File::open(path).map_err(|e| e.to_string())?;
    let mss = MediaSourceStream::new(Box::new(src), Default::default());
    let mut hint = Hint::new();
    
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        hint.with_extension(ext);
    }
    
    // Probe the media format
    let probed = symphonia::default::get_probe().format(&hint, mss, &Default::default(), &Default::default())
        .map_err(|e| e.to_string())?;
    
    // Process audio frames and convert to WAV
    // Implementation would go here
    
    Ok(Vec::new()) // Placeholder
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_processor.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_storage.rs ---
//! Content-addressable storage for assets with SQLite metadata

use bevy::prelude::*;
use rusqlite::{Connection, params, OptionalExtension};
use sha2::{Sha256, Digest};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use uuid::Uuid;
use valkey::ValkeyClient;

pub struct AssetStorage {
    db: Mutex<Connection>,
    base_path: PathBuf,
    asset_cache: Mutex<HashMap<String, HandleUntyped>>,
    valkey_client: ValkeyClient,
}

impl AssetStorage {
    pub fn new() -> Self {
        // Create storage directory if needed
        let base_path = Path::new("assets").to_path_buf();
        std::fs::create_dir_all(&base_path).expect("Failed to create assets directory");
        
        // Initialize SQLite database
        let db_path = base_path.join("asset_metadata.db");
        let conn = Connection::open(&db_path).expect("Failed to open asset database");
        
        // Create tables if they don't exist
        conn.execute(
            "CREATE TABLE IF NOT EXISTS assets (
                id TEXT PRIMARY KEY,
                path TEXT NOT NULL,
                format TEXT NOT NULL,
                size INTEGER NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            )",
            [],
        ).expect("Failed to create assets table");
        
        conn.execute(
            "CREATE TABLE IF NOT EXISTS asset_versions (
                asset_id TEXT NOT NULL,
                version INTEGER NOT NULL,
                hash TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                PRIMARY KEY (asset_id, version)
            )",
            [],
        ).expect("Failed to create asset_versions table");
        
        Self {
            db: Mutex::new(conn),
            base_path,
            asset_cache: Mutex::new(HashMap::new()),
            valkey_client: ValkeyClient::new("redis://127.0.0.1:6379").expect("Failed to connect to Valkey"),
        }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        // Register asset types and setup hot reloading
        app.add_asset::<crate::asset_manager::bevy_asset_bridge::CustomAsset>()
            .add_system(Self::hot_reload_assets);
    }

    pub fn store_asset(&self, data: &[u8], format: &str) -> String {
        // Calculate content hash
        let mut hasher = Sha256::new();
        hasher.update(data);
        let hash = hex::encode(hasher.finalize());
        
        // Create storage path
        let storage_path = self.base_path.join(&hash);
        
        // Write file if it doesn't exist
        if !storage_path.exists() {
            std::fs::write(&storage_path, data).expect("Failed to write asset");
        }
        
        // Insert metadata into database
        let conn = self.db.lock().unwrap();
        conn.execute(
            "INSERT OR IGNORE INTO assets (id, path, format, size, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?5)",
            params![
                &hash,
                storage_path.to_str().unwrap(),
                format,
                data.len() as i64,
                chrono::Utc::now().timestamp(),
            ],
        ).expect("Failed to insert asset metadata");
        
        // Cache asset data in Valkey with 1 hour expiration
        self.valkey_client.set_ex(&hash, data, 3600)
            .expect("Failed to cache asset in Valkey");
        
        hash
    }

    pub fn get_asset_path(&self, asset_id: &str) -> Option<PathBuf> {
        let conn = self.db.lock().unwrap();
        let mut stmt = conn.prepare("SELECT path FROM assets WHERE id = ?1")
            .expect("Failed to prepare statement");
        
        stmt.query_row(params![asset_id], |row| {
            Ok(PathBuf::from(row.get::<_, String>(0)?)
        }).ok()
    }
    
    /// Get asset data with Valkey caching
    pub fn get_asset_data(&self, asset_id: &str) -> Option<Vec<u8>> {
        // Try to get from Valkey cache
        if let Ok(Some(data)) = self.valkey_client.get::<Vec<u8>>(asset_id) {
            return Some(data);
        }
        
        // Fall back to disk if not in cache
        if let Some(path) = self.get_asset_path(asset_id) {
            if let Ok(data) = std::fs::read(path) {
                // Cache in Valkey for future requests
                self.valkey_client.set_ex(asset_id, &data, 3600)
                    .expect("Failed to cache asset in Valkey");
                return Some(data);
            }
        }
        
        None
    }
    
    /// Get all asset versions that haven't been synchronized
    pub fn get_pending_updates(&self) -> Vec<(String, u64, Vec<u8>)> {
        let conn = self.db.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT av.asset_id, av.version
             FROM asset_versions av
             WHERE av.synced = 0"
        ).expect("Failed to prepare statement");
        
        let rows = stmt.query_map([], |row| {
            let asset_id: String = row.get(0)?;
            let version: u64 = row.get(1)?;
            Ok((asset_id, version))
        }).expect("Failed to query pending updates");
        
        let mut updates = Vec::new();
        for row in rows {
            let (asset_id, version) = row.unwrap();
            if let Some(data) = self.get_asset_data(&asset_id) {
                updates.push((asset_id, version, data));
            } else {
                eprintln!("Failed to read asset {}", asset_id);
            }
        }
        updates
    }

    /// Mark an asset version as synchronized
    pub fn mark_as_synced(&self, asset_id: &str, version: u64) {
        let conn = self.db.lock().unwrap();
        conn.execute(
            "UPDATE asset_versions SET synced = 1 WHERE asset_id = ?1 AND version = ?2",
            params![asset_id, version],
        ).expect("Failed to mark asset version as synced");
    }
    
    /// Get version history for an asset
    pub fn get_version_history(&self, asset_id: &str) -> Vec<crate::assets::AssetVersionInfo> {
        let conn = self.db.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT version, created_at FROM asset_versions
             WHERE asset_id = ?1 ORDER BY version DESC"
        ).expect("Failed to prepare statement");
        
        let rows = stmt.query_map(params![asset_id], |row| {
            Ok(crate::assets::AssetVersionInfo {
                version: row.get(0)?,
                timestamp: row.get(1)?,
                author: None, // Placeholder for now
            })
        }).expect("Failed to query version history");
        
        rows.map(|r| r.unwrap()).collect()
    }
    
    /// Get asset data for a specific version
    pub fn get_asset_data_for_version(&self, asset_id: &str, version: u64) -> Option<Vec<u8>> {
        let conn = self.db.lock().unwrap();
        let hash: Option<String> = conn.query_row(
            "SELECT hash FROM asset_versions WHERE asset_id = ?1 AND version = ?2",
            params![asset_id, version],
            |row| row.get(0)
        ).ok()?;
        
        hash.and_then(|h| self.get_asset_data(&h))
    }
    
    /// Restore a previous version of an asset
    pub fn restore_asset_version(&self, asset_id: &str, version: u64) -> Result<(), String> {
        // Get the content hash for the version we want to restore
        let hash = self.get_asset_data_for_version(asset_id, version)
            .ok_or_else(|| "Version not found".to_string())?;
        
        // Store the asset again to create a new version
        self.store_asset(&hash, "restored")
            .map(|_| ())
            .map_err(|e| e.to_string())
    }
    
    /// Get diff between two versions (stub for now)
    pub fn get_asset_version_diff(&self, _asset_id: &str, _version_a: u64, _version_b: u64) -> Result<crate::assets::DiffResult, String> {
        // TODO: Implement actual diff logic
        Ok(crate::assets::DiffResult::Text("Diff not implemented".to_string()))
    }

    fn hot_reload_assets(
        asset_server: Res<AssetServer>,
        storage: Res<Arc<AssetStorage>>,
    ) {
        // Check for modified assets and trigger reload
        // Implementation would monitor file changes and reload assets
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_storage.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_sync.rs ---
//! Asset synchronization with vector clocks and conflict resolution

use bevy::prelude::*;
use cpc_core::p2p::{NetworkHandler, ReconciliationEngine};
use crate::asset_manager::asset_storage::AssetStorage;
use std::sync::Arc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::assets::LockInfo;

pub struct AssetSync {
    network_handler: Arc<NetworkHandler>,
    storage: Arc<AssetStorage>,
    reconciliation: ReconciliationEngine,
    vector_clocks: HashMap<String, u64>, // asset_id to version
    locks: HashMap<String, LockInfo>, // asset_id to lock info
}

impl AssetSync {
    pub fn new(network_handler: Arc<NetworkHandler>, storage: Arc<AssetStorage>) -> Self {
        let reconciliation = ReconciliationEngine::new();
        Self {
            network_handler,
            storage,
            reconciliation,
            vector_clocks: HashMap::new(),
            locks: HashMap::new(),
        }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        app.add_system(sync_assets);
    }

    pub fn handle_asset_update(&self, asset_id: &str, version: u64, data: Vec<u8>) {
        // Handle incoming asset updates from network
        self.reconciliation.reconcile(asset_id, version, data);
    }
    
    /// Acquire lock for an asset
    pub fn acquire_lock(&mut self, asset_id: &str, user_id: Uuid, user_name: String) -> Result<(), String> {
        if let Some(lock_info) = self.locks.get(asset_id) {
            if lock_info.user_id == user_id {
                return Ok(()); // Already owned by user
            }
            return Err(format!("Asset is locked by {}", lock_info.user_name));
        }
        
        self.locks.insert(asset_id.to_string(), LockInfo { user_id, user_name });
        
        // Broadcast lock event
        self.network_handler.broadcast_lock_event(
            asset_id,
            user_id,
            user_name.clone(),
            true
        );
        
        Ok(())
    }
    
    /// Release lock for an asset
    pub fn release_lock(&mut self, asset_id: &str, user_id: Uuid) -> Result<(), String> {
        if let Some(lock_info) = self.locks.get(asset_id) {
            if lock_info.user_id != user_id {
                return Err("Only lock owner can release lock".to_string());
            }
            
            self.locks.remove(asset_id);
            
            // Broadcast unlock event
            self.network_handler.broadcast_lock_event(
                asset_id,
                user_id,
                lock_info.user_name.clone(),
                false
            );
            
            return Ok(());
        }
        Err("Asset not locked".to_string())
    }
    
    /// Handle incoming lock event
    pub fn handle_lock_event(&mut self, asset_id: &str, user_id: Uuid, user_name: String, locked: bool) {
        if locked {
            self.locks.insert(asset_id.to_string(), LockInfo { user_id, user_name });
        } else {
            self.locks.remove(asset_id);
        }
    }
    
    /// Get lock info for an asset
    pub fn get_lock_info(&self, asset_id: &str) -> Option<&LockInfo> {
        self.locks.get(asset_id)
    }
    
    /// Get current vector clock version for an asset
    pub fn get_version(&self, asset_id: &str) -> u64 {
        *self.vector_clocks.get(asset_id).unwrap_or(&0)
    }
    
    /// Increment vector clock version for an asset
    pub fn increment_version(&mut self, asset_id: &str) -> u64 {
        let version = self.vector_clocks.entry(asset_id.to_string()).or_insert(0);
        *version += 1;
        *version
    }
}

fn sync_assets(
    mut sync: ResMut<AssetSync>,
    storage: Res<Arc<AssetStorage>>,
) {
    // Propagate local asset changes to network
    for (asset_id, version, data) in storage.get_pending_updates() {
        // Only sync if we have the lock or asset isn't locked
        if sync.locks.get(&asset_id).is_none() {
            let new_version = sync.increment_version(&asset_id);
            sync.network_handler.broadcast_asset_update(&asset_id, new_version, data);
            storage.mark_as_synced(&asset_id, version);
        }
    }
    
    // Process incoming updates
    while let Some((asset_id, version, data)) = sync.network_handler.get_incoming_asset_update() {
        // Apply conflict resolution based on vector clocks
        let current_version = sync.get_version(&asset_id);
        if version > current_version {
            sync.handle_asset_update(&asset_id, version, data);
            sync.vector_clocks.insert(asset_id.to_string(), version);
        }
    }
    
    // Process incoming lock events
    while let Some((asset_id, user_id, user_name, locked)) = sync.network_handler.get_incoming_lock_event() {
        sync.handle_lock_event(&asset_id, user_id, user_name, locked);
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\asset_sync.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\bevy_asset_bridge.rs ---
//! Integration between Bevy's asset system and our custom asset manager

use bevy::prelude::*;
use bevy::asset::{AssetServer, LoadContext};
use crate::asset_manager::AssetManager;
use std::path::Path;

pub struct BevyAssetBridge {
    asset_manager: AssetManager,
}

impl BevyAssetBridge {
    pub fn new(asset_manager: AssetManager) -> Self {
        Self { asset_manager }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        app.add_asset_loader(Self::custom_asset_loader());
    }

    fn custom_asset_loader() -> Box<dyn bevy::asset::AssetLoader> {
        Box::new(CustomAssetLoader)
    }
}

struct CustomAssetLoader;

impl bevy::asset::AssetLoader for CustomAssetLoader {
    fn load<'a>(
        &'a self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> bevy::utils::BoxedFuture<'a, Result<(), anyhow::Error>> {
        Box::pin(async move {
            let path = load_context.path();
            let extension = path.extension()
                .and_then(|e| e.to_str())
                .unwrap_or("")
                .to_lowercase();

            // Handle different asset types
            match extension.as_str() {
                "png" | "jpg" | "jpeg" => self.load_image(bytes, load_context).await,
                "wav" | "mp3" | "ogg" => self.load_audio(bytes, load_context).await,
                "gltf" | "glb" | "obj" => self.load_model(bytes, load_context).await,
                _ => Err(anyhow::anyhow!("Unsupported asset type: {}", extension)),
            }
        })
    }

    fn extensions(&self) -> &[&str] {
        &["png", "jpg", "jpeg", "wav", "mp3", "ogg", "gltf", "glb", "obj"]
    }
}

impl CustomAssetLoader {
    async fn load_image<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<(), anyhow::Error> {
        // Process image using our asset manager
        // This would typically generate mipmaps, convert formats, etc.
        load_context.set_default_asset(bevy::asset::LoadedAsset::new(
            bevy::render::texture::Image::from_buffer(
                bytes,
                bevy::render::texture::ImageFormat::from_extension(
                    load_context.path().extension().unwrap().to_str().unwrap(),
                )
                .unwrap(),
            )
            .unwrap(),
        ));
        Ok(())
    }

    async fn load_audio<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<(), anyhow::Error> {
        // Convert audio to WAV format if needed
        load_context.set_default_asset(bevy::asset::LoadedAsset::new(
            bevy::audio::AudioSource { bytes: bytes.into() },
        ));
        Ok(())
    }

    async fn load_model<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<(), anyhow::Error> {
        // Process 3D model
        load_context.set_default_asset(bevy::asset::LoadedAsset::new(
            bevy::gltf::Gltf::from_slice(bytes)?,
        ));
        Ok(())
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\bevy_asset_bridge.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\mod.rs ---
//! Asset management system for CPC Studio editor

pub mod asset_processor;
pub mod asset_sync;
pub mod bevy_asset_bridge;
pub mod asset_storage;

use bevy::prelude::*;
use cpc_core::p2p::NetworkHandler;

/// Main asset manager resource
pub struct AssetManager {
    processor: asset_processor::AssetProcessor,
    sync: asset_sync::AssetSync,
    storage: asset_storage::AssetStorage,
}

impl AssetManager {
    pub fn new(network_handler: Arc<NetworkHandler>) -> Self {
        let storage = asset_storage::AssetStorage::new();
        let sync = asset_sync::AssetSync::new(network_handler.clone(), storage.clone());
        let processor = asset_processor::AssetProcessor::new(storage.clone());
        
        Self {
            processor,
            sync,
            storage,
        }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        self.storage.setup_bevy(app);
        self.sync.setup_bevy(app);
        self.processor.setup_bevy(app);
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\asset_manager\mod.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\command.rs ---
use crate::editor_core::scene::manager::SceneManager;
use serde::{Serialize, Deserialize};
use std::any::Any;
use uuid::Uuid;
use serde_json::Value;

use serde_json::Value;
use uuid::Uuid;

pub trait Command: Send + Sync {
    fn execute(&self, scene: &mut SceneManager);
    fn undo(&self, scene: &mut SceneManager);
    fn as_any(&self) -> &dyn Any;
    
    // New methods for command metadata
    fn command_type(&self) -> &str;
    fn entity_id(&self) -> Option<Uuid>;
    fn component_type(&self) -> Option<&str>;
    fn parent_id(&self) -> Option<Uuid>;
    fn serialized_component_data(&self) -> Option<Value>;
}

#[derive(Serialize, Deserialize)]
pub struct UpdateComponentCommand {
    entity_id: Uuid,
    component_type_name: String,
    old_value: Value,
    new_value: Value,
}

impl Command for UpdateComponentCommand {
    fn execute(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.insert(
                self.component_type_name.clone(),
                self.new_value.clone(),
            );
        }
    }

    fn undo(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.insert(
                self.component_type_name.clone(),
                self.old_value.clone(),
            );
        }
    }

    fn as_any(&self) -> &dyn Any { self }
    
    fn command_type(&self) -> &str { "UpdateComponent" }
    
    fn entity_id(&self) -> Option<Uuid> { Some(self.entity_id) }
    
    fn component_type(&self) -> Option<&str> { Some(&self.component_type_name) }
    
    fn parent_id(&self) -> Option<Uuid> { None }
    
    fn serialized_component_data(&self) -> Option<Value> { Some(self.new_value.clone()) }
}

#[derive(Serialize, Deserialize)]
pub struct AddComponentCommand {
    entity_id: Uuid,
    component_type_name: String,
    component_data: Value,
}

impl Command for AddComponentCommand {
    fn execute(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.insert(
                self.component_type_name.clone(),
                self.component_data.clone(),
            );
        }
    }

    fn undo(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.remove(&self.component_type_name);
        }
    }

    fn as_any(&self) -> &dyn Any { self }
    
    fn command_type(&self) -> &str { "AddComponent" }
    
    fn entity_id(&self) -> Option<Uuid> { Some(self.entity_id) }
    
    fn component_type(&self) -> Option<&str> { Some(&self.component_type_name) }
    
    fn parent_id(&self) -> Option<Uuid> { None }
    
    fn serialized_component_data(&self) -> Option<Value> { Some(self.component_data.clone()) }
}

#[derive(Serialize, Deserialize)]
pub struct RemoveComponentCommand {
    entity_id: Uuid,
    component_type_name: String,
    removed_component_data: Value,
}

impl Command for RemoveComponentCommand {
    fn execute(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.remove(&self.component_type_name);
        }
    }

    fn undo(&self, scene: &mut SceneManager) {
        if let Some(entity) = scene.get_entity_mut(self.entity_id) {
            entity.components.insert(
                self.component_type_name.clone(),
                self.removed_component_data.clone(),
            );
        }
    }

    fn as_any(&self) -> &dyn Any { self }
    
    fn command_type(&self) -> &str { "RemoveComponent" }
    
    fn entity_id(&self) -> Option<Uuid> { Some(self.entity_id) }
    
    fn component_type(&self) -> Option<&str> { Some(&self.component_type_name) }
    
    fn parent_id(&self) -> Option<Uuid> { None }
    
    fn serialized_component_data(&self) -> Option<Value> { Some(self.removed_component_data.clone()) }
}

#[derive(Serialize, Deserialize)]
pub struct CreateEntityCommand {
    entity_id: Uuid,
    parent_id: Option<Uuid>,
    initial_components: ComponentStorage,
}

impl Command for CreateEntityCommand {
    pub fn execute(&self, scene: &mut SceneManager) {
        let entity = Entity {
            id: self.entity_id,
            transform: Transform::default(),
            components: self.initial_components.clone(),
        };
        
        // Add to entity storage
        scene.entities.insert(self.entity_id, entity);
        
        // Add to hierarchy
        scene.hierarchy.add_entity(self.entity_id, self.parent_id);
    }

    fn undo(&self, scene: &mut SceneManager) {
        // Remove from hierarchy first
        scene.hierarchy.remove_entity(self.entity_id);
        
        // Then remove from entity storage
        scene.entities.remove(&self.entity_id);
    }

    fn as_any(&self) -> &dyn Any { self }
    
    fn command_type(&self) -> &str { "CreateEntity" }
    
    fn entity_id(&self) -> Option<Uuid> { Some(self.entity_id) }
    
    fn component_type(&self) -> Option<&str> { None }
    
    fn parent_id(&self) -> Option<Uuid> { self.parent_id }
    
    fn serialized_component_data(&self) -> Option<Value> { None }
}

#[derive(Serialize, Deserialize)]
pub struct DeleteEntitiesCommand {
    entities: Vec<Uuid>,
    deleted_entities: Vec<Entity>,
    parent_child_pairs: Vec<(Uuid, Uuid)>,
}

impl Command for DeleteEntitiesCommand {
    fn execute(&self, scene: &mut SceneManager) {
        for entity_id in &self.entities {
            scene.hierarchy.entities.remove(entity_id);
        }
        
        // Remove all parent-child relationships involving the deleted entities
        scene.hierarchy.parent_child_pairs.retain(|(parent, child)| {
            !self.entities.contains(parent) && !self.entities.contains(child)
        });
    }

    fn undo(&self, scene: &mut SceneManager) {
        for entity in &self.deleted_entities {
            scene.hierarchy.entities.insert(entity.id, entity.clone());
        }
        
        for (parent, child) in &self.parent_child_pairs {
            scene.hierarchy.parent_child_pairs.push((*parent, *child));
        }
    }

    fn as_any(&self) -> &dyn Any { self }
}

#[derive(Serialize, Deserialize)]
pub struct ReparentEntitiesCommand {
    entities: Vec<Uuid>,
    new_parent_id: Option<Uuid>,
    old_parents: Vec<Option<Uuid>>,
}

impl Command for ReparentEntitiesCommand {
    fn execute(&self, scene: &mut SceneManager) {
        for (i, entity_id) in self.entities.iter().enumerate() {
            if let Some(entity) = scene.hierarchy.entities.get_mut(entity_id) {
                // Remove from old parent
                if let Some(old_parent_id) = entity.parent {
                    if let Some(old_parent) = scene.hierarchy.entities.get_mut(&old_parent_id) {
                        old_parent.children.retain(|id| id != entity_id);
                    }
                }
                
                // Add to new parent
                entity.parent = self.new_parent_id;
                
                if let Some(new_parent_id) = self.new_parent_id {
                    if let Some(new_parent) = scene.hierarchy.entities.get_mut(&new_parent_id) {
                        new_parent.children.push(*entity_id);
                    }
                }
            }
        }
    }

    fn undo(&self, scene: &mut SceneManager) {
        for (i, entity_id) in self.entities.iter().enumerate() {
            if let Some(entity) = scene.hierarchy.entities.get_mut(entity_id) {
                // Remove from new parent
                if let Some(new_parent_id) = self.new_parent_id {
                    if let Some(new_parent) = scene.hierarchy.entities.get_mut(&new_parent_id) {
                        new_parent.children.retain(|id| id != entity_id);
                    }
                }
                
                // Add back to old parent
                entity.parent = self.old_parents[i];
                
                if let Some(old_parent_id) = self.old_parents[i] {
                    if let Some(old_parent) = scene.hierarchy.entities.get_mut(&old_parent_id) {
                        old_parent.children.push(*entity_id);
                    }
                }
            }
        }
    }

    fn as_any(&self) -> &dyn Any { self }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\command.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\component.rs ---
use bevy::prelude::*;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

/// Storage for components attached to an entity
#[derive(Debug, Default, Clone)]
pub struct ComponentStorage {
    components: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
}

impl ComponentStorage {
    /// Create a new empty ComponentStorage
    pub fn new() -> Self {
        Self {
            components: HashMap::new(),
        }
    }

    /// Add a component to the storage
    pub fn insert<T: Component + 'static>(&mut self, component: T) {
        let type_id = TypeId::of::<T>();
        self.components.insert(type_id, Box::new(component));
    }

    /// Get a reference to a component
    pub fn get<T: Component + 'static>(&self) -> Option<&T> {
        let type_id = TypeId::of::<T>();
        self.components.get(&type_id)
            .and_then(|boxed| boxed.downcast_ref::<T>())
    }

    /// Get a mutable reference to a component
    pub fn get_mut<T: Component + 'static>(&mut self) -> Option<&mut T> {
        let type_id = TypeId::of::<T>();
        self.components.get_mut(&type_id)
            .and_then(|boxed| boxed.downcast_mut::<T>())
    }

    /// Remove a component from the storage
    pub fn remove<T: Component + 'static>(&mut self) -> Option<T> {
        let type_id = TypeId::of::<T>();
        self.components.remove(&type_id)
            .and_then(|boxed| boxed.downcast::<T>().ok())
            .map(|boxed| *boxed)
    }

    /// Check if the storage contains a specific component type
    pub fn contains<T: Component + 'static>(&self) -> bool {
        let type_id = TypeId::of::<T>();
        self.components.contains_key(&type_id)
    }
}

/// Trait for serializable components
pub trait SerializableComponent: Component + Serialize + DeserializeOwned + 'static {}
impl<T: Component + Serialize + DeserializeOwned + 'static> SerializableComponent for T {}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\component.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\entity.rs ---
use bevy::prelude::*;
use uuid::Uuid;
use std::collections::HashMap;
use crate::editor_core::scene::component::ComponentStorage;

/// Represents an entity in the scene graph
#[derive(Debug, Clone)]
pub struct Entity {
    /// Unique identifier (UUIDv7)
    pub id: Uuid,
    /// Local transform relative to parent
    pub transform: Transform,
    /// Map of components attached to this entity
    pub components: ComponentStorage,
    /// Optional parent entity ID
    pub parent: Option<Uuid>,
    /// List of child entity IDs
    pub children: Vec<Uuid>,
}

impl Entity {
    /// Create a new entity with default transform and no components
    pub fn new() -> Self {
        Self {
            id: Uuid::new_v7(),
            transform: Transform::default(),
            components: ComponentStorage::new(),
            parent: None,
            children: Vec::new(),
        }
    }

    /// Create a new entity with a specific ID (used for deserialization)
    pub fn with_id(id: Uuid) -> Self {
        Self {
            id,
            transform: Transform::default(),
            components: ComponentStorage::new(),
            parent: None,
            children: Vec::new(),
        }
    }

    /// Add a component to the entity
    pub fn add_component<T: Component + 'static>(&mut self, component: T) {
        self.components.insert(component);
    }

    /// Get a reference to a component
    pub fn get_component<T: Component + 'static>(&self) -> Option<&T> {
        self.components.get::<T>()
    }

    /// Get a mutable reference to a component
    pub fn get_component_mut<T: Component + 'static>(&mut self) -> Option<&mut T> {
        self.components.get_mut::<T>()
    }

    /// Remove a component from the entity
    pub fn remove_component<T: Component + 'static>(&mut self) -> Option<T> {
        self.components.remove::<T>()
    }
}

impl Default for Entity {
    fn default() -> Self {
        Self::new()
    }
}

use serde::{Serialize, Deserialize};

/// Represents the full scene hierarchy
#[derive(Debug, Serialize, Deserialize)]
pub struct SceneHierarchy {
    /// Map of all entities by ID
    pub entities: HashMap<Uuid, Entity>,
    /// List of parent-child relationships
    pub parent_child_pairs: Vec<(Uuid, Uuid)>,
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\entity.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\entity_sync.rs ---
use bevy::prelude::*;
use cpc_core::p2p::{NetworkHandler, ReconciliationEngine};
use std::sync::Arc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::assets::LockInfo;
use crate::editor_core::scene::hierarchy::SceneHierarchy;

pub struct EntitySync {
    network_handler: Arc<NetworkHandler>,
    hierarchy: Arc<SceneHierarchy>,
    reconciliation: ReconciliationEngine,
    vector_clocks: HashMap<Uuid, u64>, // entity_id to version
    locks: HashMap<Uuid, LockInfo>,    // entity_id to lock info
}

impl EntitySync {
    pub fn new(network_handler: Arc<NetworkHandler>, hierarchy: Arc<SceneHierarchy>) -> Self {
        let reconciliation = ReconciliationEngine::new();
        Self {
            network_handler,
            hierarchy,
            reconciliation,
            vector_clocks: HashMap::new(),
            locks: HashMap::new(),
        }
    }

    pub fn setup_bevy(&self, app: &mut App) {
        app.add_system(sync_entities);
    }

    pub fn acquire_lock(&mut self, entity_id: Uuid, user_id: Uuid, user_name: String) -> Result<(), String> {
        if let Some(lock_info) = self.locks.get(&entity_id) {
            if lock_info.user_id == user_id {
                return Ok(()); // Already owned by user
            }
            return Err(format!("Entity is locked by {}", lock_info.user_name));
        }
        
        self.locks.insert(entity_id, LockInfo { user_id, user_name });
        
        // Broadcast lock event
        self.network_handler.broadcast_entity_lock_event(
            entity_id,
            user_id,
            user_name.clone(),
            true
        );
        
        Ok(())
    }

    pub fn release_lock(&mut self, entity_id: Uuid, user_id: Uuid) -> Result<(), String> {
        if let Some(lock_info) = self.locks.get(&entity_id) {
            if lock_info.user_id != user_id {
                return Err("Only lock owner can release lock".to_string());
            }
            
            self.locks.remove(&entity_id);
            
            // Broadcast unlock event
            self.network_handler.broadcast_entity_lock_event(
                entity_id,
                user_id,
                lock_info.user_name.clone(),
                false
            );
            
            return Ok(());
        }
        Err("Entity not locked".to_string())
    }

    pub fn handle_lock_event(&mut self, entity_id: Uuid, user_id: Uuid, user_name: String, locked: bool) {
        if locked {
            self.locks.insert(entity_id, LockInfo { user_id, user_name });
        } else {
            self.locks.remove(&entity_id);
        }
    }

    pub fn get_lock_info(&self, entity_id: Uuid) -> Option<&LockInfo> {
        self.locks.get(&entity_id)
    }
}

fn sync_entities(
    mut sync: ResMut<EntitySync>,
    hierarchy: Res<Arc<SceneHierarchy>>,
) {
    // Process incoming lock events
    while let Some((entity_id, user_id, user_name, locked)) = 
        sync.network_handler.get_incoming_entity_lock_event() 
    {
        sync.handle_lock_event(entity_id, user_id, user_name, locked);
    }
    
    // TODO: Implement entity change synchronization
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\entity_sync.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\hierarchy.rs ---
use uuid::Uuid;
use std::collections::{HashMap, HashSet};

pub struct HierarchyGraph {
    pub parent_to_children: HashMap<Option<Uuid>, HashSet<Uuid>>,
    pub child_to_parent: HashMap<Uuid, Option<Uuid>>,
}

impl HierarchyGraph {
    pub fn new() -> Self {
        HierarchyGraph {
            parent_to_children: HashMap::new(),
            child_to_parent: HashMap::new(),
        }
    }

    pub fn add_entity(&mut self, entity_id: Uuid, parent_id: Option<Uuid>) {
        // Add parent-child relationship
        self.parent_to_children
            .entry(parent_id)
            .or_insert_with(HashSet::new)
            .insert(entity_id);

        // Add child-parent relationship
        self.child_to_parent.insert(entity_id, parent_id);
    }

    pub fn remove_entity(&mut self, entity_id: Uuid) {
        if let Some(parent_id) = self.child_to_parent.remove(&entity_id) {
            // Remove from parent's children
            if let Some(children) = self.parent_to_children.get_mut(&parent_id) {
                children.remove(&entity_id);
            }
        }

        // Remove all children of this entity
        if let Some(children) = self.parent_to_children.remove(&Some(entity_id)) {
            for child_id in children {
                self.child_to_parent.remove(&child_id);
            }
        }
    }

    pub fn reparent_entity(&mut self, entity_id: Uuid, new_parent_id: Option<Uuid>) {
        self.remove_entity(entity_id);
        self.add_entity(entity_id, new_parent_id);
    }

    pub fn get_children(&self, entity_id: Option<Uuid>) -> Option<&HashSet<Uuid>> {
        self.parent_to_children.get(&entity_id)
    }

    pub fn get_parent(&self, entity_id: Uuid) -> Option<Option<Uuid>> {
        self.child_to_parent.get(&entity_id).copied()
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\hierarchy.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\manager.rs ---
use std::collections::{HashMap, VecDeque};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use crate::editor_core::scene::entity::Entity;
use crate::editor_core::scene::command::Command;
use crate::editor_core::scene::hierarchy::HierarchyGraph;
use serde::Serialize;
use tauri::AppHandle;

#[derive(Serialize)]
pub struct CommandEventPayload {
    pub command_type: String,
    pub entity_id: Option<Uuid>,
    pub component_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub component_data: Option<serde_json::Value>,
    pub parent_id: Option<Uuid>,
    pub timestamp: DateTime<Utc>,
    pub user_id: Uuid,
    pub session_id: Uuid,
    pub success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    pub version_vector: HashMap<Uuid, u64>,
}

pub struct SceneManager {
    pub current_user: Uuid,
    pub session_id: Uuid,
    pub version_vector: HashMap<Uuid, u64>,
    pub entities: HashMap<Uuid, Entity>,
    pub hierarchy: HierarchyGraph,
    undo_stack: VecDeque<Box<dyn Command>>,
    redo_stack: Vec<Box<dyn Command>>,
    #[allow(dead_code)]
    app_handle: Option<AppHandle>, // For event emission
}

impl SceneManager {
    pub fn new(current_user: Uuid, session_id: Uuid) -> Self {
        SceneManager {
            entities: HashMap::new(),
            hierarchy: HierarchyGraph::new(),
            undo_stack: VecDeque::new(),
            redo_stack: Vec::new(),
            app_handle: None,
            current_user,
            session_id,
            version_vector: HashMap::new(),
        }
    }

    pub fn set_app_handle(&mut self, app_handle: AppHandle) {
        self.app_handle = Some(app_handle);
    }

    pub fn increment_version(&mut self, entity_id: Uuid) {
        let version = self.version_vector.entry(entity_id).or_insert(0);
        *version += 1;
    }

    pub fn add_entity(&mut self, entity: Entity) {
        self.entities.insert(entity.id, entity);
    }

    pub fn get_entity(&self, id: Uuid) -> Option<&Entity> {
        self.entities.get(&id)
    }

    pub fn get_entity_mut(&mut self, id: Uuid) -> Option<&mut Entity> {
        self.entities.get_mut(&id)
    }

    pub fn remove_entity(&mut self, id: Uuid) -> Option<Entity> {
        self.entities.remove(&id)
    }

    pub fn execute_command(&mut self, command: Box<dyn Command>) -> Result<(), String> {
        command.execute(self)?;
        
        // Emit detailed command event if app handle is available
        let result = command.execute(self);
        
        if let Some(app_handle) = &self.app_handle {
            let payload = CommandEventPayload {
                command_type: command.command_type().to_string(),
                entity_id: command.entity_id(),
                component_type: command.component_type().map(|c| c.to_string()),
                component_data: command.serialized_component_data(),
                parent_id: command.parent_id(),
                timestamp: Utc::now(),
                user_id: self.current_user,
                session_id: self.session_id,
                success: result.is_ok(),
                error_message: result.as_ref().err().map(|e| e.to_string()),
                version_vector: self.version_vector.clone(),
            };
            app_handle.emit_all("command-executed", &payload)
                .map_err(|e| format!("Failed to emit event: {}", e))?;
        }
        
        result?; // Propagate error if command failed
        self.undo_stack.push_back(command);
        self.redo_stack.clear();
        Ok(())
    }

    pub fn undo(&mut self) {
        if let Some(command) = self.undo_stack.pop_back() {
            command.undo(self);
            self.redo_stack.push_back(command);
        }
    }

    pub fn redo(&mut self) {
        if let Some(command) = self.redo_stack.pop_back() {
            command.execute(self);
            self.undo_stack.push_back(command);
        }
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\manager.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\mod.rs ---
pub mod command;
pub mod manager;
pub mod entity;
pub mod component;
pub mod hierarchy;
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\mod.rs ---


--- START FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\serialization.rs ---
use bevy::prelude::*;
use rmp_serde::{Serializer, Deserializer};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use super::{Entity, ComponentStorage, SceneHierarchy};
use crate::editor_core::scene::component::SerializableComponent;

/// Represents a serializable scene
#[derive(Serialize, Deserialize)]
pub struct SceneData {
    pub entities: Vec<EntityData>,
}

/// Serializable representation of an entity
#[derive(Serialize, Deserialize)]
pub struct EntityData {
    pub id: Uuid,
    pub transform: [f32; 16], // Mat4 representation
    pub components: Vec<ComponentData>,
    pub parent: Option<Uuid>,
}

/// Serializable representation of a component
#[derive(Serialize, Deserialize)]
pub struct ComponentData {
    pub type_name: String,
    pub data: Vec<u8>, // Serialized component data
}

impl SceneHierarchy {
    /// Serialize the scene hierarchy to MessagePack bytes
    pub fn serialize(&self) -> Result<Vec<u8>, rmp_serde::encode::Error> {
        let scene_data = SceneData {
            entities: self.entities.values()
                .map(|entity| EntityData {
                    id: entity.id,
                    transform: entity.transform.compute_matrix().to_cols_array(),
                    components: entity.components.serialize_components(),
                    parent: entity.parent,
                })
                .collect(),
        };
        
        let mut buf = Vec::new();
        scene_data.serialize(&mut Serializer::new(&mut buf))?;
        Ok(buf)
    }

    /// Deserialize MessagePack bytes into a scene hierarchy
    pub fn deserialize(data: &[u8]) -> Result<Self, rmp_serde::decode::Error> {
        let mut de = Deserializer::new(data);
        let scene_data: SceneData = Deserialize::deserialize(&mut de)?;
        
        let mut hierarchy = SceneHierarchy::default();
        for entity_data in scene_data.entities {
            let mut entity = Entity::with_id(entity_data.id);
            entity.transform = Transform::from_matrix(Mat4::from_cols_array(&entity_data.transform));
            entity.parent = entity_data.parent;
            
            for comp_data in entity_data.components {
                if let Some(component) = ComponentStorage::deserialize_component(&comp_data.type_name, &comp_data.data) {
                    entity.components.insert_dyn(component);
                }
            }
            
            hierarchy.add_entity(entity);
        }
        
        Ok(hierarchy)
    }
}

impl ComponentStorage {
    /// Serialize all components into a vector of ComponentData
    pub fn serialize_components(&self) -> Vec<ComponentData> {
        // In a real implementation, we would iterate through all components
        // For now, we'll leave this as a placeholder
        // Actual implementation requires a component registry
        vec![]
    }

    /// Deserialize a component from its type name and data
    pub fn deserialize_component(type_name: &str, data: &[u8]) -> Option<Box<dyn SerializableComponent>> {
        // In a real implementation, we would match on type_name
        // and deserialize the appropriate component type
        // For now, return None
        None
    }
    
    /// Insert a dynamic serializable component
    pub fn insert_dyn(&mut self, component: Box<dyn SerializableComponent>) {
        let type_id = component.type_id();
        self.components.insert(type_id, component);
    }
}
--- END FILE: apps\cpc-studio\src-tauri\src\editor_core\scene\serialization.rs ---


--- START FILE: apps\orchestrator\Cargo.toml ---
[package]
name = "orchestrator"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
cpc-lib = { path = "../lib" }
tokio = { version = "1.0", features = ["full"] }
warp = "0.3"
tonic = "0.9"
prost = "0.11"
--- END FILE: apps\orchestrator\Cargo.toml ---


--- START FILE: apps\orchestrator\protos\cpc_orchestrator.proto ---
syntax = "proto3";

package cpc.orchestrator;

import "google/protobuf/timestamp.proto";

// Node registry service
service NodeOrchestration {
  rpc RegisterNode(NodeInfo) returns (RegistrationResponse);
  rpc Heartbeat(NodePing) returns (HeartbeatResponse);
  rpc RequestResources(ResourceRequest) returns (ResourceAllocation);
}

// Identity service
service IdentityService {
  rpc Authenticate(AuthRequest) returns (AuthResponse);
  rpc RefreshToken(RefreshRequest) returns (AuthResponse);
  rpc ManageFriends(FriendRequest) returns (FriendResponse);
}

// Discovery service
service DiscoveryService {
  rpc PublishContent(ContentMetadata) returns (PublishResponse);
  rpc SearchContent(SearchQuery) returns (SearchResults);
}

// Message definitions
message NodeInfo {
  string id = 1;
  bytes public_key = 2;
  string endpoint = 3;
  map<string, string> resources = 4; // e.g. "cpu", "memory", "bandwidth"
}

message NodePing {
  string node_id = 1;
  google.protobuf.Timestamp timestamp = 2;
}

message ResourceRequest {
  string node_id = 1;
  string resource_type = 2;
  int32 quantity = 3;
}

message ResourceAllocation {
  bool approved = 1;
  string allocation_id = 2;
  map<string, int32> allocated_resources = 3;
}

message AuthRequest {
  bytes public_key = 1;
  bytes signature = 2;
}

message AuthResponse {
  string jwt = 1;
  string refresh_token = 2;
  int64 expires_in = 3; // seconds
}

message RefreshRequest {
  string refresh_token = 1;
}

message FriendRequest {
  enum Action {
    ADD = 0;
    REMOVE = 1;
    BLOCK = 2;
  }
  string user_id = 1;
  string friend_id = 2;
  Action action = 3;
}

message FriendResponse {
  bool success = 1;
  repeated string friends = 2;
}

message ContentMetadata {
  string id = 1;
  string owner_id = 2;
  string title = 3;
  string description = 4;
  repeated string tags = 5;
}

message PublishResponse {
  bool success = 1;
  string content_id = 2;
}

message SearchQuery {
  string query = 1;
  repeated string tags = 2;
  int32 limit = 3;
}

message SearchResults {
  repeated ContentMetadata results = 1;
}

message RegistrationResponse {
  bool success = 1;
  string node_id = 2;
}

message HeartbeatResponse {
  bool acknowledged = 1;
}

// Secret management service
service SecretService {
  rpc RotateSecret(RotateSecretRequest) returns (RotateSecretResponse);
}

message RotateSecretRequest {
  string new_secret = 1;
  string admin_token = 2;
}

message RotateSecretResponse {
  bool success = 1;
  string message = 2;
}
--- END FILE: apps\orchestrator\protos\cpc_orchestrator.proto ---


--- START FILE: apps\orchestrator\src\discovery.rs ---
use tonic::{Request, Response, Status};
use crate::cpc_orchestrator::*;
use sqlx::PgPool;
use std::sync::Arc;
use opensearch::{OpenSearch, IndexParts};
use opensearch::http::request::JsonBody;
use serde_json::{json, Value};
use tracing::info;

pub struct DiscoveryService {
    db_pool: Arc<PgPool>,
    search_client: Arc<OpenSearch>,
}

impl DiscoveryService {
    pub fn new(db_pool: Arc<PgPool>, search_client: Arc<OpenSearch>) -> Self {
        Self { db_pool, search_client }
    }
}

#[tonic::async_trait]
impl DiscoveryService for DiscoveryService {
    async fn publish_content(
        &self,
        request: Request<ContentMetadata>,
    ) -> Result<Response<PublishResponse>, Status> {
        let metadata = request.into_inner();
        info!("Publishing content: {}", metadata.id);
        
        // TODO: Implement content publishing
        // 1. Insert into database
        // 2. Index in OpenSearch
        // 3. Track content availability
        
        // Example OpenSearch indexing
        let document: JsonBody<_> = json!({
            "title": metadata.title,
            "description": metadata.description,
            "tags": metadata.tags,
            "owner_id": metadata.owner_id
        }).into();
        
        match self.search_client
            .index(IndexParts::IndexId("content", &metadata.id))
            .body(document)
            .send()
            .await
        {
            Ok(_) => info!("Content indexed successfully"),
            Err(e) => tracing::error!("Failed to index content: {:?}", e),
        }
        
        Ok(Response::new(PublishResponse {
            success: true,
            content_id: metadata.id,
        }))
    }

    async fn search_content(
        &self,
        request: Request<SearchQuery>,
    ) -> Result<Response<SearchResults>, Status> {
        let query = request.into_inner();
        info!("Searching content: {}", query.query);
        
        // TODO: Implement search
        // 1. Query OpenSearch
        // 2. Return results
        
        // Example search query
        let search_query = json!({
            "query": {
                "multi_match": {
                    "query": query.query,
                    "fields": ["title", "description", "tags"]
                }
            },
            "size": query.limit
        });
        
        let mut results = Vec::new();
        
        match self.search_client
            .search()
            .index(&["content"])
            .body(search_query)
            .send()
            .await
        {
            Ok(response) => {
                let response_body: Value = response.json().await.map_err(|e| {
                    Status::internal(format!("Failed to parse search response: {:?}", e))
                })?;
                
                if let Some(hits) = response_body["hits"]["hits"].as_array() {
                    for hit in hits {
                        if let Some(source) = hit.get("_source") {
                            // TODO: Map to ContentMetadata
                            results.push(ContentMetadata {
                                id: hit["_id"].as_str().unwrap_or_default().to_string(),
                                owner_id: source["owner_id"].as_str().unwrap_or_default().to_string(),
                                title: source["title"].as_str().unwrap_or_default().to_string(),
                                description: source["description"].as_str().unwrap_or_default().to_string(),
                                tags: source["tags"]
                                    .as_array()
                                    .map(|arr| arr.iter().filter_map(|v| v.as_str().map(String::from)).collect())
                                    .unwrap_or_default(),
                            });
                        }
                    }
                }
            }
            Err(e) => tracing::error!("Search failed: {:?}", e),
        }
        
        Ok(Response::new(SearchResults { results }))
    }
}
--- END FILE: apps\orchestrator\src\discovery.rs ---


--- START FILE: apps\orchestrator\src\identity.rs ---
use tonic::{Request, Response, Status};
use crate::cpc_orchestrator::*;
use sqlx::PgPool;
use std::sync::Arc;
use ring::signature::{Ed25519KeyPair, UnparsedPublicKey, VerificationAlgorithm};
use ring::rand::SystemRandom;
use ring::signature::KeyPair;
use jsonwebtoken::{encode, decode, Header, EncodingKey, DecodingKey, Validation, Algorithm};
use serde::{Serialize, Deserialize};
use chrono::{Utc, Duration as ChronoDuration};
use crate::secret_manager::SecretManager;

pub struct IdentityService {
    db_pool: Arc<PgPool>,
    secret_manager: Arc<SecretManager>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String, // User ID
    exp: usize,  // Expiration time
}

impl IdentityService {
    pub fn new(db_pool: Arc<PgPool>, secret_manager: Arc<SecretManager>) -> Self {
        Self { db_pool, secret_manager }
    }

    fn verify_signature(&self, public_key: &[u8], signature: &[u8], message: &[u8]) -> bool {
        let peer_public_key = UnparsedPublicKey::new(&ring::signature::ED25519, public_key);
        peer_public_key.verify(message, signature).is_ok()
    }
fn generate_jwt(&self, user_id: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = Utc::now()
        .checked_add_signed(ChronoDuration::minutes(15))
        .expect("valid timestamp")
        .timestamp() as usize;
    
    let claims = Claims {
        sub: user_id.to_owned(),
        exp: expiration,
    };
    
    let secret = self.secret_manager.get_current_secret().read().unwrap().clone();
    
    encode(
        &Header::new(Algorithm::EdDSA),
        &claims,
        &EncodingKey::from_secret(secret.as_ref()),
    )
}
    }
}

#[tonic::async_trait]
impl IdentityService for IdentityService {
    async fn authenticate(
        &self,
        request: Request<AuthRequest>,
    ) -> Result<Response<AuthResponse>, Status> {
        let auth_request = request.into_inner();
        
        // TODO: Implement actual authentication
        // 1. Fetch user public key from database
        // 2. Verify signature
        // 3. Generate JWT and refresh token
        
        let jwt = self.generate_jwt("user_id")
            .map_err(|e| Status::internal(e.to_string()))?;
        
        Ok(Response::new(AuthResponse {
            jwt,
            refresh_token: "refresh_token".to_string(),
            expires_in: 900, // 15 minutes
        }))
    }

    async fn refresh_token(
        &self,
        request: Request<RefreshRequest>,
    ) -> Result<Response<AuthResponse>, Status> {
        let refresh_request = request.into_inner();
        
        // TODO: Validate refresh token
        // 1. Check token in database
        // 2. If valid, generate new JWT
        
        let jwt = self.generate_jwt("user_id")
            .map_err(|e| Status::internal(e.to_string()))?;
        
        Ok(Response::new(AuthResponse {
            jwt,
            refresh_token: refresh_request.refresh_token,
            expires_in: 900,
        }))
    }

    async fn manage_friends(
        &self,
        request: Request<FriendRequest>,
    ) -> Result<Response<FriendResponse>, Status> {
        let friend_request = request.into_inner();
        
        // TODO: Implement friend management
        // 1. Verify user authentication
        // 2. Update friends list in database based on action
        
        Ok(Response::new(FriendResponse {
            success: true,
            friends: vec![],
        }))
    }
}
--- END FILE: apps\orchestrator\src\identity.rs ---


--- START FILE: apps\orchestrator\src\main.rs ---
use tonic::transport::Server;
use std::net::SocketAddr;
use tracing_subscriber::fmt::format::FmtSpan;
use sqlx::postgres::PgPoolOptions;
use valkey::ValkeyPool;
use opensearch::OpenSearch;
use crate::{node_registry::NodeRegistryService, identity::IdentityService, discovery::DiscoveryService, metrics::MetricsService, middleware::metrics::MetricsMiddleware, secret_manager::{SecretManager, SecretStorage}};
use crate::cpc_orchestrator::node_orchestration_server::NodeOrchestrationServer;
use crate::cpc_orchestrator::identity_service_server::IdentityServiceServer;
use crate::cpc_orchestrator::discovery_service_server::DiscoveryServiceServer;

mod node_registry;
mod identity;
mod discovery;
mod metrics;
mod secret_manager;
mod cpc_orchestrator {
    tonic::include_proto!("cpc.orchestrator");
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_span_events(FmtSpan::CLOSE)
        .init();

    // Create database connection pool
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://user:password@localhost:5432/cpc".to_string());
    let db_pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    // Create Valkey connection pool
    let valkey_url = std::env::var("VALKEY_URL")
        .unwrap_or_else(|_| "redis://localhost:6379".to_string());
    let valkey_pool = ValkeyPool::new(valkey_url, 5)?;

    // Create OpenSearch client
    let search_client = OpenSearch::new(
        opensearch::http::transport::SingleNodeConnectionPool::new(
            std::env::var("OPENSEARCH_URL")
                .unwrap_or_else(|_| "http://localhost:9200".to_string())
                .parse()?
        )
    );

    // Initialize services
    let node_registry = NodeRegistryService::new(db_pool.clone());
    // Create secret manager
    let secret_manager = Arc::new(SecretManager::new(
        if std::env::var("PRODUCTION").is_ok() {
            SecretStorage::Valkey(valkey_pool.clone())
        } else {
            SecretStorage::LocalEnv
        }
    ).expect("Failed to create secret manager"));

    let identity = IdentityService::new(
        db_pool.clone(),
        secret_manager.clone()
    );
    let discovery = DiscoveryService::new(db_pool.clone(), search_client.clone());
    let metrics = MetricsService::new();

    // Start metrics server
    metrics.start_metrics_server("0.0.0.0:9090".parse()?);

    // Create gRPC server
    let addr: SocketAddr = "[::]:50051".parse()?;
    tracing::info!("gRPC server listening on {}", addr);

    // Wrap node registry with metrics middleware
    let wrapped_registry = MetricsMiddleware::new(node_registry, Arc::new(metrics.clone()));
    
    // Create secret service
    let secret_service = SecretServiceImpl::new(secret_manager.clone());

    Server::builder()
        .add_service(NodeOrchestrationServer::new(wrapped_registry))
        .add_service(IdentityServiceServer::new(identity))
        .add_service(DiscoveryServiceServer::new(discovery))
        .add_service(SecretServiceServer::new(secret_service))
        .serve(addr)
        .await?;

    Ok(())
}
--- END FILE: apps\orchestrator\src\main.rs ---


--- START FILE: apps\orchestrator\src\metrics.rs ---
use tonic::{Request, Response, Status};
use prometheus::{Encoder, TextEncoder, Registry, Gauge, Counter, Histogram, Opts, CounterVec, GaugeVec};
use std::sync::Arc;
use tokio::sync::Mutex;
use hyper::{
    service::{make_service_fn, service_fn},
    Body, Method, Request as HyperRequest, Response as HyperResponse, Server, StatusCode,
};
use std::net::SocketAddr;
use tracing::info;

pub struct MetricsService {
    registry: Arc<Mutex<Registry>>,
    rpc_counter: CounterVec,
    rpc_success: GaugeVec,
}

impl MetricsService {
    pub fn new() -> Self {
        let registry = Registry::new();
        
        // Create RPC metrics
        let rpc_counter = CounterVec::new(
            Opts::new("rpc_calls_total", "Total RPC calls"),
            &["method"]
        ).unwrap();
        
        let rpc_success = GaugeVec::new(
            Opts::new("rpc_success", "RPC call success status"),
            &["method"]
        ).unwrap();
        
        registry.register(Box::new(rpc_counter.clone())).unwrap();
        registry.register(Box::new(rpc_success.clone())).unwrap();
        
        Self {
            registry: Arc::new(Mutex::new(registry)),
            rpc_counter,
            rpc_success,
        }
    }

    pub fn start_metrics_server(&self, addr: SocketAddr) {
        let registry = self.registry.clone();
        
        tokio::spawn(async move {
            let service = make_service_fn(move |_| {
                let registry = registry.clone();
                async move {
                    Ok::<_, hyper::Error>(service_fn(move |req: HyperRequest<Body>| {
                        handle_metrics_request(req, registry.clone())
                    }))
                }
            });
            
            let server = Server::bind(&addr).serve(service);
            info!("Metrics server running on http://{}", addr);
            
            if let Err(e) = server.await {
                tracing::error!("Metrics server error: {}", e);
            }
        });
    }

    // New instrumentation methods for middleware
    pub fn record_pre_handle(&self, method: &str) {
        self.rpc_counter.with_label_values(&[method]).inc();
    }

    pub fn record_post_handle(&self, method: &str, result: &Result<Response<impl Sized>, Status>) {
        let success_value = match result {
            Ok(_) => 1.0,
            Err(_) => 0.0,
        };
        self.rpc_success.with_label_values(&[method]).set(success_value);
    }
}

async fn handle_metrics_request(
    req: HyperRequest<Body>,
    registry: Arc<Mutex<Registry>>,
) -> Result<HyperResponse<Body>, hyper::Error> {
    if req.method() != Method::GET {
        return Ok(HyperResponse::builder()
            .status(StatusCode::METHOD_NOT_ALLOWED)
            .body(Body::empty())
            .unwrap());
    }
    
    let encoder = TextEncoder::new();
    let mut buffer = vec![];
    let metric_families = registry.lock().await.gather();
    
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let response = HyperResponse::builder()
        .status(StatusCode::OK)
        .header(hyper::header::CONTENT_TYPE, encoder.format_type())
        .body(Body::from(buffer))
        .unwrap();
    
    Ok(response)
}
--- END FILE: apps\orchestrator\src\metrics.rs ---


--- START FILE: apps\orchestrator\src\node_registry.rs ---
use tonic::{Request, Response, Status};
use crate::cpc_orchestrator::*;
use sqlx::PgPool;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;
use tracing::info;

pub struct NodeRegistryService {
    db_pool: Arc<PgPool>,
    // TODO: Add Valkey cache client
    // TODO: Add node health monitor
}

impl NodeRegistryService {
    pub fn new(db_pool: Arc<PgPool>) -> Self {
        Self { db_pool }
    }
}

#[tonic::async_trait]
impl NodeOrchestration for NodeRegistryService {
    async fn register_node(
        &self,
        request: Request<NodeInfo>,
    ) -> Result<Response<RegistrationResponse>, Status> {
        let node_info = request.into_inner();
        info!("Registering node: {}", node_info.id);
        
        // TODO: Implement node registration logic
        // 1. Validate node information
        // 2. Insert into database
        // 3. Start health monitoring
        
        Ok(Response::new(RegistrationResponse {
            success: true,
            node_id: node_info.id,
        }))
    }

    async fn heartbeat(
        &self,
        request: Request<NodePing>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let ping = request.into_inner();
        info!("Heartbeat from node: {}", ping.node_id);
        
        // TODO: Update node last_seen timestamp in database
        // TODO: Check resource availability
        
        Ok(Response::new(HeartbeatResponse { acknowledged: true }))
    }

    async fn request_resources(
        &self,
        request: Request<ResourceRequest>,
    ) -> Result<Response<ResourceAllocation>, Status> {
        let resource_request = request.into_inner();
        info!("Resource request from node: {}", resource_request.node_id);
        
        // TODO: Implement resource allocation logic
        // 1. Check resource availability
        // 2. Allocate resources
        // 3. Return allocation details
        
        Ok(Response::new(ResourceAllocation {
            approved: true,
            allocation_id: "temp_allocation_id".to_string(),
            allocated_resources: Default::default(),
        }))
    }
}
--- END FILE: apps\orchestrator\src\node_registry.rs ---


--- START FILE: apps\orchestrator\src\secret_manager.rs ---
use std::sync::{Arc, RwLock};
use valkey::ValkeyPool;
use jsonwebtoken::DecodingKey;
use thiserror::Error;
use tracing::info;

#[derive(Error, Debug)]
pub enum SecretError {
    #[error("Secret not found")]
    NotFound,
    #[error("Storage error: {0}")]
    StorageError(String),
}

pub enum SecretStorage {
    LocalEnv,
    Valkey(ValkeyPool),
    // Vault(VaultClient) - To be implemented later
}

pub struct SecretManager {
    current_secret: Arc<RwLock<String>>,
    previous_secrets: Arc<RwLock<Vec<String>>>,
    storage: SecretStorage,
}

impl SecretManager {
    pub fn new(storage: SecretStorage) -> Result<Self, SecretError> {
        let secret = Self::load_secret(&storage)?;
        Ok(Self {
            current_secret: Arc::new(RwLock::new(secret)),
            previous_secrets: Arc::new(RwLock::new(Vec::new())),
            storage,
        })
    }

    fn load_secret(storage: &SecretStorage) -> Result<String, SecretError> {
        match storage {
            SecretStorage::LocalEnv => {
                std::env::var("JWT_SECRET")
                    .map_err(|_| SecretError::NotFound)
            }
            SecretStorage::Valkey(pool) => {
                let mut conn = pool.get().map_err(|e| SecretError::StorageError(e.to_string()))?;
                let secret: String = conn.get("jwt_secrets:active")
                    .map_err(|e| SecretError::StorageError(e.to_string()))?;
                Ok(secret)
            }
        }
    }

    pub fn get_current_secret(&self) -> Arc<RwLock<String>> {
        self.current_secret.clone()
    }

    pub fn get_decoding_key(&self) -> DecodingKey {
        DecodingKey::from_secret(self.current_secret.read().unwrap().as_bytes())
    }

    pub async fn rotate_secret(&self, new_secret: String) -> Result<(), SecretError> {
        info!("Rotating JWT secret");
        let mut current = self.current_secret.write().unwrap();
        let mut previous = self.previous_secrets.write().unwrap();
        
        // Move current to previous secrets
        previous.push(current.clone());
        
        // Update current secret
        *current = new_secret.clone();
        
        // Update storage
        match &self.storage {
            SecretStorage::Valkey(pool) => {
                let mut conn = pool.get().map_err(|e| SecretError::StorageError(e.to_string()))?;
                conn.set("jwt_secrets:active", &new_secret)
                    .map_err(|e| SecretError::StorageError(e.to_string()))?;
            }
            _ => {} // Local env doesn't support rotation
        }
        
        Ok(())
    }
}
--- END FILE: apps\orchestrator\src\secret_manager.rs ---


--- START FILE: apps\orchestrator\src\secret_service.rs ---
use tonic::{Request, Response, Status};
use crate::cpc_orchestrator::secret_service_server::SecretService;
use crate::cpc_orchestrator::{RotateSecretRequest, RotateSecretResponse};
use crate::secret_manager::SecretManager;
use std::sync::Arc;
use jsonwebtoken::DecodingKey;
use tracing::info;

pub struct SecretServiceImpl {
    secret_manager: Arc<SecretManager>,
}

impl SecretServiceImpl {
    pub fn new(secret_manager: Arc<SecretManager>) -> Self {
        Self { secret_manager }
    }
}

#[tonic::async_trait]
impl SecretService for SecretServiceImpl {
    async fn rotate_secret(
        &self,
        request: Request<RotateSecretRequest>,
    ) -> Result<Response<RotateSecretResponse>, Status> {
        let req = request.into_inner();
        
        // Validate admin credentials
        if req.admin_token != std::env::var("ADMIN_TOKEN").unwrap_or_default() {
            return Err(Status::permission_denied("Invalid admin token"));
        }
        
        // Validate new secret strength
        if req.new_secret.len() < 32 {
            return Err(Status::invalid_argument("Secret must be at least 32 characters"));
        }
        
        // Perform rotation
        self.secret_manager.rotate_secret(req.new_secret.clone())
            .await
            .map_err(|e| Status::internal(e.to_string()))?;
        
        info!("JWT secret rotated successfully");
        
        Ok(Response::new(RotateSecretResponse {
            success: true,
            message: "Secret rotated successfully".to_string(),
        }))
    }
}
--- END FILE: apps\orchestrator\src\secret_service.rs ---


--- START FILE: apps\orchestrator\src\middleware\metrics.rs ---
use tonic::{Request, Response, Status};
use crate::cpc_orchestrator::NodeOrchestration;
use crate::metrics::MetricsService;
use std::sync::Arc;

pub struct MetricsMiddleware<T> {
    inner: T,
    metrics: Arc<MetricsService>,
}

impl<T> MetricsMiddleware<T> {
    pub fn new(inner: T, metrics: Arc<MetricsService>) -> Self {
        Self { inner, metrics }
    }
}

#[tonic::async_trait]
impl<T: NodeOrchestration + Send + Sync + 'static> NodeOrchestration for MetricsMiddleware<T> {
    async fn register_node(
        &self,
        request: Request<NodeInfo>,
    ) -> Result<Response<RegistrationResponse>, Status> {
        self.metrics.record_pre_handle("register_node");
        let result = self.inner.register_node(request).await;
        self.metrics.record_post_handle("register_node", &result);
        result
    }

    async fn heartbeat(
        &self,
        request: Request<NodePing>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        self.metrics.record_pre_handle("heartbeat");
        let result = self.inner.heartbeat(request).await;
        self.metrics.record_post_handle("heartbeat", &result);
        result
    }

    async fn request_resources(
        &self,
        request: Request<ResourceRequest>,
    ) -> Result<Response<ResourceAllocation>, Status> {
        self.metrics.record_pre_handle("request_resources");
        let result = self.inner.request_resources(request).await;
        self.metrics.record_post_handle("request_resources", &result);
        result
    }
}
--- END FILE: apps\orchestrator\src\middleware\metrics.rs ---


--- START FILE: apps\orchestrator\src\middleware\mod.rs ---
pub mod metrics;
--- END FILE: apps\orchestrator\src\middleware\mod.rs ---


--- START FILE: apps\pds\Cargo.toml ---
[package]
name = "pds"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
cpc-lib = { path = "../lib" }
tauri = { version = "1.0", features = [] }
tokio = { version = "1.0", features = ["full"] }
rusqlite = "0.29"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
aes-gcm = "0.12"
sha2 = "0.10"
merkle-cbt = "0.2"
rand = "0.8"
chrono = "0.4"          # For timestamp handling
hex = "0.4"             # For hex encoding
mime_guess = "2.0"      # For MIME type detection
notify = "6.1.1"        # For file watching
tokio = { version = "1.0", features = ["sync", "rt-multi-thread"] }
async-trait = "0.1"     # For async trait support
--- END FILE: apps\pds\Cargo.toml ---


--- START FILE: apps\pds\frontend\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cooperative Peer Cloud</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.js"></script>
</body>
</html>
--- END FILE: apps\pds\frontend\index.html ---


--- START FILE: apps\pds\frontend\vite.config.js ---
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'dist'
  }
})
--- END FILE: apps\pds\frontend\vite.config.js ---


--- START FILE: apps\pds\frontend\src\App.svelte ---
<script>
  import { onMount } from 'svelte';
  import { refreshNetworkStatus } from './stores/network';
  
  import NetworkStatusDashboard from './components/NetworkStatusDashboard.svelte';
  import StorageConfigPanel from './components/StorageConfigPanel.svelte';
  import ContentBrowser from './components/ContentBrowser.svelte';
  import SettingsPage from './components/SettingsPage.svelte';
  
  let currentView = 'network';
  
  // Initialize network status on app start
  onMount(() => {
    refreshNetworkStatus();
  });
</script>

<main>
  <header>
    <h1>Cooperative Peer Cloud</h1>
    <nav>
      <button class:active={currentView === 'network'} on:click={() => currentView = 'network'}>
        Network
      </button>
      <button class:active={currentView === 'storage'} on:click={() => currentView = 'storage'}>
        Storage
      </button>
      <button class:active={currentView === 'content'} on:click={() => currentView = 'content'}>
        Content
      </button>
      <button class:active={currentView === 'settings'} on:click={() => currentView = 'settings'}>
        Settings
      </button>
    </nav>
  </header>

  <div class="content">
    {#if currentView === 'network'}
      <NetworkStatusDashboard />
    {:else if currentView === 'storage'}
      <StorageConfigPanel />
    {:else if currentView === 'content'}
      <ContentBrowser />
    {:else if currentView === 'settings'}
      <SettingsPage />
    {/if}
  </div>
</main>

<style>
  :global(body) {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #f0f0f0;
  }
  
  main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 0;
    border-bottom: 1px solid #ddd;
    margin-bottom: 20px;
  }
  
  nav {
    display: flex;
    gap: 10px;
  }
  
  button {
    padding: 8px 15px;
    background: #eee;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  
  button.active {
    background: #007bff;
    color: white;
  }
  
  .content {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
</style>
--- END FILE: apps\pds\frontend\src\App.svelte ---


--- START FILE: apps\pds\frontend\src\components\ContentBrowser.svelte ---
<script>
  import { invoke } from '@tauri-apps/api';
  import { onMount } from 'svelte';
  import { getFileIcon, getFileCategory } from '../utils/fileUtils';
  
  let currentPath = "/";
  let files = [];
  let filteredFiles = [];
  let isLoading = true;
  let searchQuery = '';
  let selectedCategory = 'all';
  let previewFile = null;
  let showUploadDialog = false;

  async function loadFiles() {
    isLoading = true;
    try {
      files = await invoke('list_files', { path: currentPath });
      filterFiles();
    } catch (err) {
      console.error('Failed to list files:', err);
      files = [];
      filteredFiles = [];
    }
    isLoading = false;
  }

  function filterFiles() {
    filteredFiles = files.filter(file => {
      const matchesSearch = file.toLowerCase().includes(searchQuery.toLowerCase());
      const categoryMatch = selectedCategory === 'all' ||
                           getFileCategory(file) === selectedCategory;
      return matchesSearch && categoryMatch;
    });
  }

  onMount(loadFiles);

  function navigate(path: string) {
    currentPath = path;
    loadFiles();
  }

  async function downloadFile(filename) {
    try {
      await invoke('download_file', {
        path: `${currentPath}/${filename}`
      });
      console.log(`Downloaded file: ${filename}`);
    } catch (err) {
      console.error('Download failed:', err);
    }
  }

  async function previewFile(filename) {
    try {
      const preview = await invoke('get_file_preview', {
        path: `${currentPath}/${filename}`
      });
      previewFile = {
        name: filename,
        type: preview.content_type,
        data: preview.data
      };
    } catch (err) {
      console.error('Preview failed:', err);
    }
  }
</script>

<div class="content-browser">
  <h2>Content Browser</h2>
  
  <div class="path-navigation">
    <button on:click={() => navigate('/')}>Home</button>
    <span>{currentPath}</span>
  </div>

  <div class="controls">
    <input type="text" placeholder="Search files..." bind:value={searchQuery} on:input={filterFiles}>
    <select bind:value={selectedCategory} on:change={filterFiles}>
      <option value="all">All Files</option>
      <option value="documents">Documents</option>
      <option value="images">Images</option>
      <option value="archives">Archives</option>
      <option value="code">Code</option>
    </select>
    <button on:click={() => showUploadDialog = true}>Upload</button>
  </div>

  {#if isLoading}
    <p>Loading files...</p>
  {:else}
    <div class="file-list">
      {#each filteredFiles as file}
        <div class="file-item">
          <span class="file-icon">{getFileIcon(file)}</span>
          <span class="file-name">{file}</span>
          <div class="file-actions">
            <button on:click|stopPropagation={() => downloadFile(file)}>Download</button>
            <button on:click|stopPropagation={() => previewFile(file)}>Preview</button>
          </div>
        </div>
      {:else}
        <p>No files found</p>
      {/each}
    </div>
  {/if}
  
  {#if previewFile}
    <div class="preview-modal">
      <button class="close-btn" on:click={() => previewFile = null}>✕</button>
      <h3>Preview: {previewFile.name}</h3>
      {#if previewFile.type.startsWith('text/')}
        <pre>{previewFile.data}</pre>
      {:else if previewFile.type.startsWith('image/')}
        <img src={`data:${previewFile.type};base64,${previewFile.data}`} alt="Preview">
      {:else}
        <p>Preview not available for this file type</p>
      {/if}
    </div>
  {/if}
</div>

<style>
  .content-browser {
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
  }
  .path-navigation {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
  }
  .controls input, .controls select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  .controls button {
    padding: 8px 12px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  .file-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
  }
  .file-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    border: 1px solid #eee;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
    position: relative;
  }
  .file-item:hover {
    background: #f9f9f9;
  }
  .file-icon {
    font-size: 24px;
    margin-bottom: 5px;
  }
  .file-name {
    font-size: 12px;
    text-align: center;
    word-break: break-all;
  }
  .file-actions {
    display: flex;
    gap: 5px;
    margin-top: 5px;
  }
  .file-actions button {
    padding: 4px 8px;
    font-size: 10px;
    background: #f0f0f0;
    color: #333;
    border: 1px solid #ddd;
    border-radius: 3px;
    cursor: pointer;
  }
  .preview-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    z-index: 1000;
    max-width: 80vw;
    max-height: 80vh;
    overflow: auto;
  }
  .preview-modal pre {
    max-width: 100%;
    overflow: auto;
    background: #f8f8f8;
    padding: 10px;
    border-radius: 4px;
  }
  .preview-modal img {
    max-width: 100%;
    max-height: 60vh;
    display: block;
    margin: 0 auto;
  }
  .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #666;
  }
</style>
--- END FILE: apps\pds\frontend\src\components\ContentBrowser.svelte ---


--- START FILE: apps\pds\frontend\src\components\NetworkStatusDashboard.svelte ---
<script>
  import { networkStatus, refreshNetworkStatus } from '../stores/network';
  import { onMount } from 'svelte';
  
  onMount(() => {
    refreshNetworkStatus();
  });
  
  function formatDate(date) {
    if (!date) return 'Never';
    return new Date(date).toLocaleTimeString();
  }
</script>

<div class="dashboard">
  <h2>Network Status</h2>
  
  {#if $networkStatus.error}
    <div class="error-state">
      <div class="error-icon">⚠️</div>
      <p>Failed to load network data: {$networkStatus.error}</p>
      <button on:click={refreshNetworkStatus}>Retry</button>
    </div>
  {:else}
    <div class="status-indicator">
      <div class="led {$networkStatus.data.isOnline ? 'online' : 'offline'}"></div>
      <span>{$networkStatus.data.isOnline ? 'Online' : 'Offline'}</span>
    </div>
    
    <div class="metrics">
      <div class="metric" title="Number of peers currently connected">
        <h3>Connected Peers</h3>
        <p>{$networkStatus.data.peers}</p>
      </div>
      <div class="metric" title="Current upload speed">
        <h3>Upload</h3>
        <p>{$networkStatus.data.bandwidthUp.toFixed(2)} KB/s</p>
      </div>
      <div class="metric" title="Current download speed">
        <h3>Download</h3>
        <p>{$networkStatus.data.bandwidthDown.toFixed(2)} KB/s</p>
      </div>
    </div>
    
    <div class="footer">
      <div class="timestamp">
        Last updated: {formatDate($networkStatus.lastUpdated)}
      </div>
      <button on:click={refreshNetworkStatus} disabled={$networkStatus.loading}>
        {#if $networkStatus.loading}
          <span class="spinner">⏳</span> Refreshing...
        {:else}
          Refresh
        {/if}
      </button>
    </div>
  {/if}
</div>

<style>
  .dashboard {
    padding: 20px;
    background: #f5f5f5;
    border-radius: 8px;
    position: relative;
  }
  .status-indicator {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
  }
  .led {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
  }
  .online { background: green; }
  .offline { background: red; }
  .metrics {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
  }
  .metric {
    flex: 1;
    text-align: center;
    position: relative;
    cursor: help;
  }
  .metric:hover::after {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 5px;
    border-radius: 4px;
    white-space: nowrap;
    z-index: 100;
  }
  .footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .timestamp {
    font-size: 0.8em;
    color: #666;
  }
  .error-state {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .error-icon {
    font-size: 1.5em;
  }
  .spinner {
    margin-right: 5px;
  }
</style>
--- END FILE: apps\pds\frontend\src\components\NetworkStatusDashboard.svelte ---


--- START FILE: apps\pds\frontend\src\components\SettingsPage.svelte ---
<script>
  import { invoke } from '@tauri-apps/api';
  
  let encryptionKey = '';
  let networkProtocols = ['TCP', 'QUIC', 'WebSockets'];
  let selectedProtocols = ['TCP', 'WebSockets'];
  let bootstrapNodes = ['/ip4/10.0.0.1/tcp/4001/p2p/12D3KooWM8s3KQT7LKUpZb7hY4E3AbM4WZ1xWKQqQK3q4VZ7V5v2'];
  let newNode = '';

  async function saveSettings() {
    try {
      // TODO: Implement protocol configuration commands
      console.log('Settings saved');
    } catch (err) {
      console.error('Failed to save settings:', err);
    }
  }

  function addBootstrapNode() {
    if (newNode.trim()) {
      bootstrapNodes = [...bootstrapNodes, newNode.trim()];
      newNode = '';
    }
  }
</script>

<div class="settings-page">
  <h2>Settings</h2>
  
  <div class="settings-section">
    <h3>Encryption</h3>
    <div class="form-group">
      <label>Current Encryption Key:</label>
      <input type="password" bind:value={encryptionKey} placeholder="Enter new key..." />
    </div>
  </div>

  <div class="settings-section">
    <h3>Network Protocols</h3>
    {#each networkProtocols as protocol}
      <label>
        <input type="checkbox" bind:group={selectedProtocols} value={protocol} />
        {protocol}
      </label>
    {/each}
  </div>

  <div class="settings-section">
    <h3>Bootstrap Nodes</h3>
    <div class="node-list">
      {#each bootstrapNodes as node}
        <div class="node-item">{node}</div>
      {/each}
    </div>
    <div class="add-node">
      <input type="text" bind:value={newNode} placeholder="Enter new node address..." />
      <button on:click={addBootstrapNode}>Add Node</button>
    </div>
  </div>

  <button on:click={saveSettings} class="save-button">Save Settings</button>
</div>

<style>
  .settings-page {
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .settings-section {
    margin: 20px 0;
    padding: 15px;
    border: 1px solid #eee;
    border-radius: 4px;
  }
  .form-group {
    margin: 10px 0;
  }
  .node-list {
    margin: 10px 0;
  }
  .node-item {
    padding: 5px;
    background: #f9f9f9;
    margin: 5px 0;
    border-radius: 4px;
  }
  .add-node {
    display: flex;
    gap: 10px;
    margin-top: 15px;
  }
  .save-button {
    margin-top: 20px;
    width: 100%;
  }
</style>
--- END FILE: apps\pds\frontend\src\components\SettingsPage.svelte ---


--- START FILE: apps\pds\frontend\src\components\StorageConfigPanel.svelte ---
<script>
  import { onMount } from 'svelte';
  import { storageMetrics, refreshStorageMetrics, setStorageLimit } from '../stores/storage';
  import StorageUsageChart from './StorageUsageChart.svelte';
  
  let newStorageLimit = 1; // Temporary value for slider
  
  onMount(() => {
    refreshStorageMetrics();
  });
  
  function formatDate(date) {
    if (!date) return 'Never';
    return new Date(date).toLocaleTimeString();
  }
  
  function bytesToGB(bytes) {
    return bytes / (1024 * 1024 * 1024);
  }
  
  async function handleSetStorageLimit() {
    try {
      await setStorageLimit(newStorageLimit);
    } catch (err) {
      console.error('Failed to set storage limit:', err);
    }
  }
</script>

<div class="storage-panel">
  <h2>Storage Configuration</h2>
  
  {#if $storageMetrics.error}
    <div class="error-state">
      <div class="error-icon">⚠️</div>
      <p>Failed to load storage data: {$storageMetrics.error}</p>
      <button on:click={refreshStorageMetrics}>Retry</button>
    </div>
  {:else}
    <div class="config-item">
      <label>Storage Limit (GB):</label>
      <input type="range" min="1" max="2048" bind:value={newStorageLimit}
             on:change={handleSetStorageLimit}
             disabled={$storageMetrics.loading}>
      <span title="Set storage limit in gigabytes">{newStorageLimit} GB</span>
    </div>

    <div class="usage-meter">
      <div class="meter-bar" style={`width: ${Math.min(100, (bytesToGB($storageMetrics.data.used) / newStorageLimit) * 100)}%`} />
      <div class="meter-labels">
        <span>0 GB</span>
        <span title="Current storage usage">{bytesToGB($storageMetrics.data.used).toFixed(2)} GB used</span>
        <span title="Storage limit">{newStorageLimit.toFixed(1)} GB</span>
      </div>
    </div>
    
    <div class="chart-section">
      <h3>Storage Breakdown</h3>
      <StorageUsageChart breakdown={$storageMetrics.data.breakdown} />
    </div>
    
    <div class="footer">
      <div class="timestamp">
        Last updated: {formatDate($storageMetrics.lastUpdated)}
      </div>
      <button on:click={refreshStorageMetrics} disabled={$storageMetrics.loading}>
        {#if $storageMetrics.loading}
          <span class="spinner">⏳</span> Refreshing...
        {:else}
          Refresh
        {/if}
      </button>
    </div>
  {/if}
</div>

<style>
  .storage-panel {
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .config-item {
    margin: 15px 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  input[type="range"] {
    flex: 1;
  }
  .usage-meter {
    margin-top: 20px;
    height: 20px;
    background: #eee;
    border-radius: 10px;
    position: relative;
  }
  .meter-bar {
    height: 100%;
    background: #4CAF50;
    border-radius: 10px;
    transition: width 0.3s ease;
  }
  .meter-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
    font-size: 0.8em;
    color: #666;
  }
  .meter-labels span:hover {
    text-decoration: underline;
    cursor: help;
  }
  .chart-section {
    margin-top: 20px;
  }
  .footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 15px;
  }
  .timestamp {
    font-size: 0.8em;
    color: #666;
  }
  .error-state {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .error-icon {
    font-size: 1.5em;
  }
  .spinner {
    margin-right: 5px;
  }
</style>
--- END FILE: apps\pds\frontend\src\components\StorageConfigPanel.svelte ---


--- START FILE: apps\pds\frontend\src\components\StorageUsageChart.svelte ---
<script>
  import { onMount, afterUpdate } from 'svelte';
  import { Chart, PieController, ArcElement, Tooltip, Legend } from 'chart.js';
  import { Pie } from 'svelte-chartjs';

  Chart.register(PieController, ArcElement, Tooltip, Legend);

  export let breakdown = {};

  let chart;
  let chartElement;

  // Initialize chart when component mounts
  onMount(() => {
    if (chartElement) {
      chart = new Chart(chartElement, {
        type: 'pie',
        data: {
          labels: breakdown.labels || [],
          datasets: [{
            data: breakdown.values || [],
            backgroundColor: [
              '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
              '#9966FF', '#FF9F40', '#8AC926', '#1982C4'
            ]
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const value = context.raw || 0;
                  const gb = (value / 1e9).toFixed(2);
                  return `${context.label}: ${gb} GB`;
                }
              }
            }
          }
        }
      });
    }
  });

  // Update chart when data changes
  afterUpdate(() => {
    if (chart) {
      chart.data.labels = breakdown.labels || [];
      chart.data.datasets[0].data = breakdown.values || [];
      chart.update();
    }
  });
</script>

<div class="chart-container">
  <canvas bind:this={chartElement} />
</div>

<style>
  .chart-container {
    width: 100%;
    height: 300px;
    margin-top: 20px;
  }
</style>
--- END FILE: apps\pds\frontend\src\components\StorageUsageChart.svelte ---


--- START FILE: apps\pds\frontend\src\stores\network.js ---
import { writable } from 'svelte/store';
import { invoke } from '@tauri-apps/api';

// Initialize the store with default values including state flags
export const networkStatus = writable({
  data: {
    peers: 0,
    isOnline: false,
    bandwidthUp: 0,
    bandwidthDown: 0
  },
  loading: false,
  error: null,
  lastUpdated: null
});

let intervalId = null;

function setupRefresh() {
  if (intervalId) {
    clearInterval(intervalId);
  }
  intervalId = setInterval(refreshNetworkStatus, 5000);
}

function handleVisibilityChange() {
  if (document.visibilityState === 'visible') {
    setupRefresh();
    refreshNetworkStatus(); // Refresh immediately when tab becomes visible
  } else {
    clearInterval(intervalId);
    intervalId = null;
  }
}

document.addEventListener('visibilitychange', handleVisibilityChange);

export async function refreshNetworkStatus() {
  networkStatus.update(status => ({ ...status, loading: true, error: null }));
  try {
    const data = await invoke('get_network_status');
    networkStatus.set({
      data,
      loading: false,
      error: null,
      lastUpdated: new Date()
    });
  } catch (err) {
    networkStatus.update(status => ({
      ...status,
      loading: false,
      error: err.message,
      lastUpdated: new Date()
    }));
  }
}

// Start the periodic refresh initially
setupRefresh();
--- END FILE: apps\pds\frontend\src\stores\network.js ---


--- START FILE: apps\pds\frontend\src\stores\storage.js ---
import { writable } from 'svelte/store';
import { invoke } from '@tauri-apps/api';

// Initialize the store with default values
export const storageMetrics = writable({
  data: {
    used: 0,
    limit: 1 * 1024 * 1024 * 1024, // Default 1GB in bytes
    breakdown: {}
  },
  loading: false,
  error: null,
  lastUpdated: null
});

let intervalId = null;

function setupRefresh() {
  if (intervalId) {
    clearInterval(intervalId);
  }
  intervalId = setInterval(refreshStorageMetrics, 10000); // Refresh every 10 seconds
}

function handleVisibilityChange() {
  if (document.visibilityState === 'visible') {
    setupRefresh();
    refreshStorageMetrics(); // Refresh immediately when tab becomes visible
  } else {
    clearInterval(intervalId);
    intervalId = null;
  }
}

document.addEventListener('visibilitychange', handleVisibilityChange);

export async function refreshStorageMetrics() {
  storageMetrics.update(metrics => ({ ...metrics, loading: true, error: null }));
  
  try {
    // Fetch storage usage
    const usage = await invoke('get_storage_usage');
    
    // Fetch storage breakdown
    const breakdown = await invoke('get_storage_breakdown');
    
    storageMetrics.set({
      data: {
        used: usage.used,
        limit: usage.limit,
        breakdown
      },
      loading: false,
      error: null,
      lastUpdated: new Date()
    });
  } catch (err) {
    storageMetrics.update(metrics => ({
      ...metrics,
      loading: false,
      error: err.message,
      lastUpdated: new Date()
    }));
  }
}

export async function setStorageLimit(limitGB) {
  const limitBytes = limitGB * 1024 * 1024 * 1024;
  try {
    await invoke('set_storage_limit', { limit: limitBytes });
    await refreshStorageMetrics();
  } catch (err) {
    console.error('Failed to set storage limit:', err);
    throw err;
  }
}

// Start the periodic refresh initially
setupRefresh();
--- END FILE: apps\pds\frontend\src\stores\storage.js ---


--- START FILE: apps\pds\frontend\src\utils\fileUtils.js ---
export function getFileIcon(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const icons = {
    jpg: '🖼️',
    jpeg: '🖼️',
    png: '🖼️',
    gif: '🖼️',
    bmp: '🖼️',
    svg: '🖼️',
    webp: '🖼️',
    mp3: '🔊',
    wav: '🔊',
    ogg: '🔊',
    mp4: '🎬',
    mov: '🎬',
    avi: '🎬',
    pdf: '📄',
    doc: '📝',
    docx: '📝',
    xls: '📊',
    xlsx: '📊',
    ppt: '📑',
    pptx: '📑',
    txt: '📝',
    md: '📝',
    js: '📜',
    jsx: '📜',
    ts: '📜',
    tsx: '📜',
    json: '📄',
    html: '🌐',
    htm: '🌐',
    css: '🎨',
    scss: '🎨',
    zip: '📦',
    rar: '📦',
    '7z': '📦',
    tar: '📦',
    gz: '📦',
    exe: '⚙️',
    dll: '⚙️',
    sh: '💻',
    bat: '💻',
    ps1: '💻',
    py: '🐍',
    java: '☕',
    class: '☕',
    jar: '☕',
    cs: '⚙️',
    go: '🐹',
    php: '🐘',
    rb: '💎',
    rs: '🦀'
  };
  return icons[ext] || '📄';
}

export function getFileCategory(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const categories = {
    jpg: 'images',
    jpeg: 'images',
    png: 'images',
    gif: 'images',
    bmp: 'images',
    svg: 'images',
    webp: 'images',
    mp3: 'audio',
    wav: 'audio',
    ogg: 'audio',
    mp4: 'video',
    mov: 'video',
    avi: 'video',
    pdf: 'documents',
    doc: 'documents',
    docx: 'documents',
    xls: 'documents',
    xlsx: 'documents',
    ppt: 'documents',
    pptx: 'documents',
    txt: 'documents',
    md: 'documents',
    js: 'code',
    jsx: 'code',
    ts: 'code',
    tsx: 'code',
    json: 'code',
    html: 'code',
    htm: 'code',
    css: 'code',
    scss: 'code',
    zip: 'archives',
    rar: 'archives',
    '7z': 'archives',
    tar: 'archives',
    gz: 'archives',
    exe: 'executables',
    dll: 'executables',
    sh: 'scripts',
    bat: 'scripts',
    ps1: 'scripts',
    py: 'scripts',
    java: 'code',
    class: 'code',
    jar: 'code',
    cs: 'code',
    go: 'code',
    php: 'code',
    rb: 'code',
    rs: 'code'
  };
  return categories[ext] || 'other';
}
--- END FILE: apps\pds\frontend\src\utils\fileUtils.js ---


--- START FILE: apps\pds\src\commands.rs ---
//! Tauri commands for PDS frontend interaction

use crate::AppState;
use tauri::State;
use std::sync::{Mutex, Arc};
use cpc_lib::{storage::LruStorage, net::Network};

/// Network status information
#[derive(serde::Serialize)]
pub struct NetworkStatus {
    peers: usize,
    is_online: bool,
    bandwidth_up: f64,
    bandwidth_down: f64,
}

/// Get current network status
#[tauri::command]
pub fn get_network_status(state: State<AppState>) -> Result<NetworkStatus, String> {
    let network = state.network.lock().map_err(|e| e.to_string())?;
    
    // Get actual network metrics from libp2p
    let peers = network.get_peer_count();
    let is_online = network.is_online();
    let (bandwidth_up, bandwidth_down) = network.get_bandwidth_usage();
    
    Ok(NetworkStatus {
        peers,
        is_online,
        bandwidth_up: bandwidth_up as f64 / 1024.0, // Convert to KB/s
        bandwidth_down: bandwidth_down as f64 / 1024.0,
    })
}

/// Set storage limit
/// Storage metrics information
#[derive(serde::Serialize)]
pub struct StorageMetrics {
    used: u64,
    limit: u64,
}

/// Get current storage usage
#[tauri::command]
pub fn get_storage_usage(state: State<AppState>) -> Result<StorageMetrics, String> {
    let storage = state.storage.lock().map_err(|e| e.to_string())?;
    let used = storage.get_used_space().map_err(|e| e.to_string())?;
    let limit = storage.get_limit();
    Ok(StorageMetrics { used, limit })
}

/// Set storage limit
#[tauri::command]
pub fn set_storage_limit(limit: u64, state: State<AppState>) -> Result<(), String> {
    let mut storage = state.storage.lock().map_err(|e| e.to_string())?;
    storage.set_limit(limit).map_err(|e| e.to_string())
}

/// List files in a directory
#[tauri::command]
pub fn list_files(path: String, state: State<AppState>) -> Result<Vec<String>, String> {
    let storage = state.storage.lock().map_err(|e| e.to_string())?;
    storage.list_files(&path).map_err(|e| e.to_string())
}
use sha2::{Sha256, Digest};
use crate::{file_utils::{FileProcessor, EncryptedChunk}, metadata::{FileMetadata, MetadataStore}};
use std::path::Path;
use crate::storage::NetworkError;

/// Upload a file to the network using content addressing
#[tauri::command]
pub async fn upload_file(
    path: String,
    state: State<'_, AppState>,
) -> Result<String, String> {
    let processor = FileProcessor::new(state.config.encryption_key);
    let (chunks, metadata) = processor.chunk_and_encrypt(Path::new(&path))
        .map_err(|e| e.to_string())?;

    let mut network = state.network.lock()
        .map_err(|e| e.to_string())?;
    let metadata_store = state.metadata_store.lock()
        .map_err(|e| e.to_string())?;

    // Store file metadata
    network.store_metadata(&metadata)
        .await
        .map_err(|e| e.to_string())?;
    metadata_store.store_file_metadata(&metadata)
        .map_err(|e| e.to_string())?;

    // Store each chunk with its content address
    for (i, chunk) in chunks.iter().enumerate() {
        let chunk_hash = hex::encode(&chunk.data);
        metadata_store.store_chunk_metadata(&ChunkMetadata {
            file_content_address: metadata.content_address.clone(),
            index: i,
            hash: chunk_hash.clone(),
            size: chunk.data.len(),
            nonce: chunk.nonce.to_vec(),
        }).map_err(|e| e.to_string())?;

        network.store_chunk(&chunk_hash, &chunk.data)
            .await
            .map_err(|e| e.to_string())?;
    }

    Ok(metadata.content_address)
}

/// Download a file from the network using its content address
#[tauri::command]
pub async fn download_file(
    content_address: String,
    state: State<'_, AppState>,
) -> Result<Vec<u8>, String> {
    let network = state.network.lock()
        .map_err(|e| e.to_string())?;
    let metadata_store = state.metadata_store.lock()
        .map_err(|e| e.to_string())?;

    // Get file metadata
    let metadata = network.get_metadata(&content_address)
        .await
        .map_err(|e| e.to_string())?;

    // Get chunk metadata
    let chunks_meta = metadata_store.get_chunks_for_file(&content_address)
        .map_err(|e| e.to_string())?;

    // Retrieve chunks with retry logic
    let mut chunks = Vec::new();
    for chunk_meta in chunks_meta {
        let mut retries = 3;
        loop {
            match network.get_chunk(&chunk_meta.hash).await {
            Ok(data) => {
                // Validate chunk hash
                let mut hasher = Sha256::new();
                hasher.update(&data);
                let computed_hash = hex::encode(hasher.finalize());

                if computed_hash != chunk_meta.hash {
                    return Err(NetworkError::VerificationFailed(format!(
                        "Chunk {} hash mismatch",
                        chunk_meta.index
                    )).to_string());
                }

                chunks.push(EncryptedChunk {
                    data,
                    nonce: chunk_meta.nonce.clone().try_into()
                        .map_err(|_| "Invalid nonce length".to_string())?,
                });
                break;
            }
                Err(NetworkError::NotFound) if retries > 0 => {
                    retries -= 1;
                    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                }
                Err(e) => return Err(e.to_string()),
            }
        }
    }

    // Verify Merkle tree
    crate::file_utils::verify_merkle_tree(&chunks, &metadata.content_address)
        .map_err(|e| NetworkError::VerificationFailed(e).to_string())?;

    let processor = FileProcessor::new(state.config.encryption_key);
    processor.decrypt_and_assemble(chunks)
}
--- END FILE: apps\pds\src\commands.rs ---


--- START FILE: apps\pds\src\conflict_resolver.rs ---
use std::collections::HashMap;
use crate::metadata::FileMetadata;

pub struct FileConflict {
    pub file_id: String,
    pub local_version: u64,
    pub remote_version: u64,
    pub local_metadata: FileMetadata,
    pub remote_metadata: FileMetadata,
}

pub enum ConflictResolution {
    KeepLocal,
    KeepRemote,
    Merge,
}

pub struct ConflictResolver {
    pending_conflicts: HashMap<String, FileConflict>,
}

impl ConflictResolver {
    pub fn new() -> Self {
        Self { pending_conflicts: HashMap::new() }
    }
    
    pub fn detect_conflict(
        &mut self,
        local_metadata: &FileMetadata,
        remote_metadata: &FileMetadata
    ) -> Option<FileConflict> {
        if local_metadata.version != remote_metadata.version {
            let conflict = FileConflict {
                file_id: local_metadata.content_address.clone(),
                local_version: local_metadata.version,
                remote_version: remote_metadata.version,
                local_metadata: local_metadata.clone(),
                remote_metadata: remote_metadata.clone(),
            };
            self.pending_conflicts.insert(local_metadata.content_address.clone(), conflict.clone());
            Some(conflict)
        } else {
            None
        }
    }
    
    pub fn resolve_conflict(
        &mut self,
        file_id: &str,
        resolution: ConflictResolution
    ) -> Result<(), String> {
        self.pending_conflicts.remove(file_id)
            .ok_or_else(|| "Conflict not found".to_string())?;
        
        // In a real implementation, we would apply the resolution here
        // For now, we just remove the conflict from pending
        Ok(())
    }

    pub fn get_conflicts(&self) -> Vec<FileConflict> {
        self.pending_conflicts.values().cloned().collect()
    }
}
--- END FILE: apps\pds\src\conflict_resolver.rs ---


--- START FILE: apps\pds\src\file_utils.rs ---
use aes_gcm::{Aes256Gcm, KeyInit, aead::{Aead, generic_array::GenericArray}};
use std::path::Path;
use std::io::{Read};
use merkle_cbt::{merkle_tree::Merge, MerkleTree};
use sha2::{Sha256, Digest};
use crate::metadata::{FileMetadata, ChunkMetadata};
use chrono::Utc;
use hex;
use mime_guess;
use std::fs;

const CHUNK_SIZE: usize = 262_144; // 256KB

/// Represents an encrypted chunk with its associated nonce
pub struct EncryptedChunk {
    pub data: Vec<u8>,
    pub nonce: [u8; 12],
}

pub struct FileProcessor {
    encryption_key: [u8; 32],
}

impl FileProcessor {
    pub fn new(encryption_key: [u8; 32]) -> Self {
        Self { encryption_key }
    }

    /// Chunk, encrypt, and generate metadata for a file
    pub fn chunk_and_encrypt(&self, path: &Path) -> Result<(Vec<EncryptedChunk>, FileMetadata), String> {
        let mut file = fs::File::open(path).map_err(|e| e.to_string())?;
        let total_size = fs::metadata(path).map_err(|e| e.to_string())?.len();
        let mime_type = mime_guess::from_path(path)
            .first_or_octet_stream()
            .to_string();

        let mut chunks = Vec::new();
        let mut hashes = Vec::new();

        let cipher = Aes256Gcm::new(GenericArray::from_slice(&self.encryption_key));

        loop {
            let mut chunk = vec![0; CHUNK_SIZE];
            let bytes_read = file.read(&mut chunk).map_err(|e| e.to_string())?;
            if bytes_read == 0 { break }

            chunk.truncate(bytes_read);
            let nonce: [u8; 12] = rand::random(); // Generate unique nonce
            let nonce_generic = GenericArray::from_slice(&nonce);
            let encrypted_chunk = cipher.encrypt(nonce_generic, chunk.as_ref())
                .map_err(|e| e.to_string())?;

            let mut hasher = Sha256::new();
            hasher.update(&encrypted_chunk);
            let hash = hasher.finalize().to_vec();
            hashes.push(hash.clone());

            chunks.push(EncryptedChunk {
                data: encrypted_chunk,
                nonce,
            });
        }

        // Build Merkle tree and get root hash
        let merkle_tree = MerkleTree::<Vec<u8>, Sha256>::build(hashes);
        let merkle_root = merkle_tree.root();
        let content_address = hex::encode(merkle_root);

        let file_metadata = FileMetadata {
            content_address: content_address.clone(),
            version: 1,
            original_path: path.to_string_lossy().to_string(),
            size: total_size,
            chunk_count: chunks.len(),
            mime_type,
            created_at: Utc::now().timestamp(),
        };

        Ok((chunks, file_metadata))
    }

    /// Decrypt and assemble chunks using stored nonces
    pub fn decrypt_and_assemble(&self, chunks: Vec<EncryptedChunk>) -> Result<Vec<u8>, String> {
        let cipher = Aes256Gcm::new(GenericArray::from_slice(&self.encryption_key));
        let mut assembled = Vec::new();

        for chunk in chunks {
            let nonce = GenericArray::from_slice(&chunk.nonce);
            let decrypted = cipher.decrypt(nonce, chunk.data.as_ref())
                .map_err(|e| e.to_string())?;
            assembled.extend(decrypted);
        }

        Ok(assembled)
    }
}

/// Verify Merkle tree structure of downloaded chunks
pub fn verify_merkle_tree(metadata: &FileMetadata) -> Result<(), String> {
    // This would be implemented using actual chunk data
    // For now, we'll just simulate verification
    if metadata.content_address.is_empty() {
        return Err("Empty content address".to_string());
    }
    Ok(())
    let hashes: Vec<Vec<u8>> = chunks.iter()
        .map(|chunk| {
            let mut hasher = Sha256::new();
            hasher.update(&chunk.data);
            hasher.finalize().to_vec()
        })
        .collect();

    let tree = MerkleTree::<Vec<u8>, Sha256>::build(hashes);
    let computed_root = hex::encode(tree.root());
    
    if computed_root != root_hash {
        return Err("Merkle root verification failed".to_string());
    }
    Ok(())
}

/// Compare two file metadata versions and return chunk differences
pub fn compute_file_diff(
    old_metadata: &FileMetadata,
    new_metadata: &FileMetadata
) -> Vec<ChunkDiff> {
    let mut diffs = Vec::new();
    
    // Simple version comparison - in real implementation we'd compare Merkle trees
    if old_metadata.version != new_metadata.version {
        diffs.push(ChunkDiff {
            chunk_index: 0,
            old_hash: old_metadata.content_address.clone(),
            new_hash: new_metadata.content_address.clone(),
        });
    }
    
    diffs
}

/// Apply diff to file metadata
pub fn apply_file_diff(
    metadata: &mut FileMetadata,
    diff: Vec<ChunkDiff>
) -> Result<(), String> {
    for chunk_diff in diff {
        // In real implementation we'd update specific chunks
        metadata.content_address = chunk_diff.new_hash;
        metadata.version += 1;
    }
    Ok(())
}
--- END FILE: apps\pds\src\file_utils.rs ---


--- START FILE: apps\pds\src\file_watcher.rs ---
use notify::{RecommendedWatcher, Watcher, RecursiveMode, Event, EventKind};
use std::path::Path;
use tokio::sync::mpsc;
use crate::network::{Network, NetworkMessage, FileChangeNotification};
use crate::file_utils::compute_file_diff;
use crate::metadata::FileMetadata;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct FileWatcher {
    watcher: RecommendedWatcher,
    network: Arc<Mutex<dyn Network + Send + Sync>>,
    metadata_store: Arc<Mutex<dyn FileMetadataStore + Send + Sync>>,
}

impl FileWatcher {
    pub fn new(
        network: Arc<Mutex<dyn Network + Send + Sync>>,
        metadata_store: Arc<Mutex<dyn FileMetadataStore + Send + Sync>>
    ) -> Result<(Self, mpsc::Receiver<Event>), String> {
        let (tx, rx) = mpsc::channel(100);
        let network_clone = Arc::clone(&network);
        let metadata_clone = Arc::clone(&metadata_store);
        
        let watcher = notify::recommended_watcher(move |res| {
            if let Ok(event) = res {
                tx.blocking_send(event).unwrap();
                
                // Handle file change events
                if let EventKind::Modify(_) | EventKind::Create(_) | EventKind::Remove(_) = event.kind {
                    for path in event.paths {
                        let net = Arc::clone(&network_clone);
                        let meta = Arc::clone(&metadata_clone);
                        tokio::spawn(async move {
                            if let Err(e) = Self::handle_file_change(&path, net, meta).await {
                                log::error!("Error handling file change: {}", e);
                            }
                        });
                    }
                }
            }
        }).map_err(|e| e.to_string())?;
        
        Ok(Self { watcher, network, metadata_store }, rx)
    }

    pub fn watch(&mut self, path: &Path) -> notify::Result<()> {
        self.watcher.watch(path, RecursiveMode::Recursive)
    }

    async fn handle_file_change(
        path: &Path,
        network: Arc<Mutex<dyn Network + Send + Sync>>,
        metadata_store: Arc<Mutex<dyn FileMetadataStore + Send + Sync>>
    ) -> Result<(), String> {
        let file_path = path.to_string_lossy().to_string();
        
        // Get current file metadata
        let mut meta_store = metadata_store.lock().await;
        let current_meta = meta_store.get_metadata(&file_path).await?;
        
        // Compute new metadata (this would involve actual file processing)
        // For simplicity, we'll just increment version
        let new_meta = FileMetadata {
            content_address: "new_merkle_root".to_string(),
            version: current_meta.version + 1,
            ..current_meta.clone()
        };
        
        // Compute diff between versions
        let diff = compute_file_diff(&current_meta, &new_meta);
        
        // Update metadata store
        meta_store.store_metadata(&file_path, new_meta).await?;
        
        // Broadcast change notification
        let msg = NetworkMessage::FileChangeNotification(FileChangeNotification {
            file_path: file_path.clone(),
            merkle_root: "new_merkle_root".to_string(),
            version: current_meta.version + 1,
        });
        
        let mut net = network.lock().await;
        net.broadcast(msg).await.map_err(|e| e.to_string())
    }
}

pub trait FileMetadataStore {
    async fn get_metadata(&self, file_path: &str) -> Result<FileMetadata, String>;
    async fn store_metadata(&self, file_path: &str, metadata: FileMetadata) -> Result<(), String>;
}
--- END FILE: apps\pds\src\file_watcher.rs ---


--- START FILE: apps\pds\src\lib.rs ---
pub mod metadata_store;
--- END FILE: apps\pds\src\lib.rs ---


--- START FILE: apps\pds\src\main.rs ---
//! Personal Data Server for Cooperative Peer Cloud

use std::sync::{Arc, Mutex};
use cpc_lib::{storage::LruStorage, net::{NetworkBuilder, Network}, crypto::KeyPair};
use tauri::Builder;
use tokio::sync::mpsc;

mod commands;
mod metadata;
mod file_watcher;
mod conflict_resolver;
use commands::{get_network_status, get_storage_usage, set_storage_limit, list_files, upload_file, download_file};
use metadata::MetadataStore;
use file_watcher::FileWatcher;
use conflict_resolver::ConflictResolver;

/// Application state shared with Tauri commands
pub struct AppState {
    storage: Arc<Mutex<LruStorage>>,
    network: Arc<Mutex<dyn Network>>,
    metadata_store: Arc<Mutex<MetadataStore>>,
    config: Config,
    file_watcher: Mutex<FileWatcher>,
    file_event_rx: Mutex<mpsc::Receiver<notify::Event>>,
    conflict_resolver: Mutex<ConflictResolver>,
}

/// Configuration for the application
pub struct Config {
    encryption_key: [u8; 32],
}

fn main() {
    println!("Personal Data Server starting...");

    // Initialize local storage
    let storage = Arc::new(Mutex::new(LruStorage::new(1024 * 1024 * 1024))); // 1GB limit

    // Generate keys for encryption
    let keys = KeyPair::generate_x25519();
    let encryption_key = keys.private_key().as_ref().try_into().expect("Invalid key length");

    // Initialize metadata store
    let metadata_store = Arc::new(Mutex::new(
        MetadataStore::new("pds_metadata.db").expect("Failed to create metadata store")
    ));

    // Connect to P2P network
    let network = Arc::new(Mutex::new(
        NetworkBuilder::new()
            .with_websocket()
            .build()
    ));

    // Initialize file watcher
    let (file_watcher, file_event_rx) = FileWatcher::new().expect("Failed to create file watcher");

    // Initialize conflict resolver
    let conflict_resolver = ConflictResolver::new();

    // Create application state
    let app_state = AppState {
        storage,
        network,
        metadata_store,
        config: Config { encryption_key },
        file_watcher: Mutex::new(file_watcher),
        file_event_rx: Mutex::new(file_event_rx),
        conflict_resolver: Mutex::new(conflict_resolver),
    };

    // Initialize Tauri application with state
    Builder::default()
        .manage(app_state)
        .invoke_handler(tauri::generate_handler![
            get_network_status,
            get_storage_usage,
            set_storage_limit,
            list_files,
            upload_file,
            download_file
        ])
        .run(tauri::generate_context!())
        .expect("error running tauri application");
}
--- END FILE: apps\pds\src\main.rs ---


--- START FILE: apps\pds\src\metadata.rs ---
use chrono::Utc;
use rusqlite::{params, Connection, Result};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Mutex;

/// Metadata for a stored file
#[derive(Debug, Serialize, Deserialize)]
pub struct FileMetadata {
    pub content_address: String, // Merkle root hash
    pub original_path: String,
    pub size: u64,
    pub chunk_count: usize,
    pub mime_type: String,
    pub created_at: i64,
    pub version: u64,
}

/// Metadata for an individual chunk
#[derive(Debug, Serialize, Deserialize)]
pub struct ChunkMetadata {
    pub file_content_address: String,
    pub index: usize,
    pub hash: String,
    pub size: usize,
    pub nonce: Vec<u8>,
}

/// SQLite-based metadata storage
pub struct MetadataStore {
    conn: Mutex<Connection>,
}

impl MetadataStore {
    pub fn new(db_path: &str) -> Result<Self> {
        let conn = Connection::open(db_path)?;
        conn.execute(
            "CREATE TABLE IF NOT EXISTS file_metadata (
                content_address TEXT PRIMARY KEY,
                original_path TEXT NOT NULL,
                size INTEGER NOT NULL,
                chunk_count INTEGER NOT NULL,
                mime_type TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                version INTEGER NOT NULL
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS chunk_metadata (
                id INTEGER PRIMARY KEY,
                file_content_address TEXT NOT NULL,
                index INTEGER NOT NULL,
                hash TEXT NOT NULL,
                size INTEGER NOT NULL,
                nonce BLOB NOT NULL,
                FOREIGN KEY(file_content_address) REFERENCES file_metadata(content_address)
            )",
            [],
        )?;

        Ok(MetadataStore {
            conn: Mutex::new(conn),
        })
    }

    /// Store file metadata
    pub fn store_file_metadata(&self, metadata: &FileMetadata) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO file_metadata (content_address, original_path, size, chunk_count, mime_type, created_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
            params![
                metadata.content_address,
                metadata.original_path,
                metadata.size,
                metadata.chunk_count,
                metadata.mime_type,
                metadata.created_at,
                metadata.version as i64
            ],
        )?;
        Ok(())
    }

    /// Store chunk metadata
    pub fn store_chunk_metadata(&self, metadata: &ChunkMetadata) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO chunk_metadata (file_content_address, index, hash, size, nonce)
             VALUES (?1, ?2, ?3, ?4, ?5)",
            params![
                metadata.file_content_address,
                metadata.index,
                metadata.hash,
                metadata.size,
                metadata.nonce
            ],
        )?;
        Ok(())
    }

    /// Get specific version of file metadata
    pub fn get_versioned_metadata(&self, original_path: &str, version: u64) -> Result<FileMetadata> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT content_address, original_path, size, chunk_count, mime_type, created_at, version
             FROM file_metadata WHERE original_path = ?1 AND version = ?2",
        )?;
        
        stmt.query_row(params![original_path, version as i64], |row| {
            Ok(FileMetadata {
                content_address: row.get(0)?,
                original_path: row.get(1)?,
                size: row.get(2)?,
                chunk_count: row.get(3)?,
                mime_type: row.get(4)?,
                created_at: row.get(5)?,
                version: row.get(6)? as u64,
            })
        })
    }

    /// Get file metadata by content address
    pub fn get_file_metadata(&self, content_address: &str) -> Result<FileMetadata> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT content_address, original_path, size, chunk_count, mime_type, created_at, version
             FROM file_metadata WHERE content_address = ?1",
        )?;
        
        stmt.query_row(params![content_address], |row| {
            Ok(FileMetadata {
                content_address: row.get(0)?,
                original_path: row.get(1)?,
                size: row.get(2)?,
                chunk_count: row.get(3)?,
                mime_type: row.get(4)?,
                created_at: row.get(5)?,
                version: row.get(6)? as u64,
            })
        })
    }

    /// Get all chunks for a file
    pub fn get_chunks_for_file(&self, content_address: &str) -> Result<Vec<ChunkMetadata>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT file_content_address, index, hash, size, nonce
             FROM chunk_metadata WHERE file_content_address = ?1 ORDER BY index",
        )?;
        
        let rows = stmt.query_map(params![content_address], |row| {
            Ok(ChunkMetadata {
                file_content_address: row.get(0)?,
                index: row.get(1)?,
                hash: row.get(2)?,
                size: row.get(3)?,
                nonce: row.get(4)?,
            })
        })?;
        
        rows.collect()
    }
}
--- END FILE: apps\pds\src\metadata.rs ---


--- START FILE: apps\pds\src\metadata_store.rs ---
use crate::metadata::FileMetadata;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

pub struct InMemoryMetadataStore {
    store: Mutex<HashMap<String, Vec<FileMetadata>>>,
}

impl InMemoryMetadataStore {
    pub fn new() -> Self {
        Self {
            store: Mutex::new(HashMap::new()),
        }
    }
}

#[async_trait::async_trait]
pub trait FileMetadataStore: Send + Sync {
    async fn get_metadata(&self, file_path: &str) -> Result<FileMetadata, String>;
    async fn store_metadata(&self, file_path: &str, metadata: FileMetadata) -> Result<(), String>;
    async fn get_versioned_metadata(&self, file_path: &str, version: u64) -> Result<FileMetadata, String>;
}

#[async_trait::async_trait]
impl FileMetadataStore for InMemoryMetadataStore {
    async fn get_metadata(&self, file_path: &str) -> Result<FileMetadata, String> {
        let store = self.store.lock().map_err(|e| e.to_string())?;
        store.get(file_path)
            .and_then(|versions| versions.last().cloned())
            .ok_or_else(|| "Metadata not found".to_string())
    }

    async fn store_metadata(&self, file_path: &str, metadata: FileMetadata) -> Result<(), String> {
        let mut store = self.store.lock().map_err(|e| e.to_string())?;
        let versions = store.entry(file_path.to_string()).or_insert_with(Vec::new);
        versions.push(metadata);
        Ok(())
    }
    
    async fn get_versioned_metadata(&self, file_path: &str, version: u64) -> Result<FileMetadata, String> {
        let store = self.store.lock().map_err(|e| e.to_string())?;
        store.get(file_path)
            .and_then(|versions| versions.iter().find(|m| m.version == version).cloned())
            .ok_or_else(|| "Versioned metadata not found".to_string())
    }
}
--- END FILE: apps\pds\src\metadata_store.rs ---


--- START FILE: apps\pds\src\network.rs ---
use serde::{Serialize, Deserialize};
use crate::file_utils::ChunkDiff;

#[derive(Serialize, Deserialize, Debug)]
pub enum NetworkMessage {
    ChangeNotification(ChangeNotification),
    ChangeAck(ChangeAck),
    // New messages for file synchronization
    FileChangeNotification(FileChangeNotification),
    FilePatchRequest(FilePatchRequest),
    FilePatch(FilePatch),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ChangeNotification {
    pub file_id: String,
    pub version: u64,
    pub diff: Vec<ChunkDiff>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ChangeAck {
    pub file_id: String,
    pub accepted: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileChangeNotification {
    pub file_path: String,
    pub merkle_root: String,
    pub version: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FilePatchRequest {
    pub file_path: String,
    pub base_version: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FilePatch {
    pub file_path: String,
    pub patches: Vec<u8>, // Serialized patch data
    pub new_version: u64,
}
--- END FILE: apps\pds\src\network.rs ---


--- START FILE: apps\pds\src\network_handler.rs ---
use std::sync::{Arc, Mutex};
use crate::{
    conflict_resolver::{ConflictResolver, FileConflict, ConflictResolution},
    file_utils::{verify_merkle_tree, compute_file_diff, apply_file_diff},
    metadata::{FileMetadata, MetadataStore},
    network::{FileChangeNotification, FilePatchRequest, FilePatch},
    storage::NetworkError,
};

pub struct NetworkHandler {
    metadata_store: Arc<dyn MetadataStore + Send + Sync>,
    conflict_resolver: Arc<Mutex<ConflictResolver>>,
}

impl NetworkHandler {
    pub fn new(
        metadata_store: Arc<dyn MetadataStore + Send + Sync>,
        conflict_resolver: Arc<Mutex<ConflictResolver>>,
    ) -> Self {
        Self {
            metadata_store,
            conflict_resolver,
        }
    }

    /// Process file change notification from remote peer
    pub async fn handle_file_change_notification(
        &self,
        notification: FileChangeNotification,
    ) -> Result<Option<FilePatchRequest>, NetworkError> {
        let local_metadata = match self.metadata_store.get_metadata(&notification.file_path).await {
            Ok(meta) => meta,
            Err(_) => {
                // File doesn't exist locally, request full sync
                return Ok(Some(FilePatchRequest {
                    file_path: notification.file_path,
                    base_version: 0,
                }));
            }
        };

        // Check if we need an update
        if local_metadata.version < notification.version {
            // Request patch from current version
            Ok(Some(FilePatchRequest {
                file_path: notification.file_path,
                base_version: local_metadata.version,
            }))
        } else {
            // We're up-to-date
            Ok(None)
        }
    }

    /// Generate patch for requested file version
    pub async fn handle_file_patch_request(
        &self,
        request: FilePatchRequest,
    ) -> Result<Option<FilePatch>, NetworkError> {
        let current_metadata = self.metadata_store.get_metadata(&request.file_path).await?;
        
        // Verify we have a newer version
        if current_metadata.version <= request.base_version {
            return Ok(None);
        }

        // Get base metadata (could be stored or reconstructed)
        let base_metadata = self.metadata_store
            .get_versioned_metadata(&request.file_path, request.base_version)
            .await?;

        // Compute diff between versions
        let patches = compute_file_diff(&base_metadata, &current_metadata);

        Ok(Some(FilePatch {
            file_path: request.file_path,
            patches: bincode::serialize(&patches).map_err(|_| NetworkError::SerializationError)?,
            new_version: current_metadata.version,
        }))
    }

    /// Apply received patch to local file
    pub async fn handle_file_patch(
        &self,
        patch: FilePatch,
    ) -> Result<(), NetworkError> {
        let mut local_metadata = self.metadata_store.get_metadata(&patch.file_path).await?;
        
        // Verify version compatibility
        if local_metadata.version != patch.new_version - 1 {
            // Check for conflict
            let remote_metadata = FileMetadata {
                version: patch.new_version,
                ..local_metadata.clone()
            };
            
            let conflict = self.conflict_resolver
                .lock()
                .map_err(|_| NetworkError::StorageError("Mutex poisoned".into()))?
                .detect_conflict(&local_metadata, &remote_metadata);
            
            if let Some(conflict) = conflict {
                // Handle conflict resolution (simplified)
                let resolution = ConflictResolution::Merge; // In real impl, would prompt user
                self.resolve_conflict(conflict, resolution).await?;
            }
            return Err(NetworkError::InvalidData);
        }

        // Deserialize patches
        let patches: Vec<ChunkDiff> = bincode::deserialize(&patch.patches)
            .map_err(|_| NetworkError::SerializationError)?;

        // Apply patches to metadata
        apply_file_diff(&mut local_metadata, patches)
            .map_err(|e| NetworkError::StorageError(e))?;

        // Verify Merkle tree integrity
        verify_merkle_tree(&local_metadata)
            .map_err(|e| NetworkError::VerificationFailed(e))?;

        // Update metadata store
        self.metadata_store.store_metadata(&patch.file_path, local_metadata).await?;

        Ok(())
    }

    /// Resolve file conflict with chosen strategy
    async fn resolve_conflict(
        &self,
        conflict: FileConflict,
        resolution: ConflictResolution,
    ) -> Result<(), NetworkError> {
        let mut resolver = self.conflict_resolver
            .lock()
            .map_err(|_| NetworkError::StorageError("Mutex poisoned".into()))?;
        
        resolver.resolve_conflict(&conflict.file_id, resolution)
            .map_err(|e| NetworkError::StorageError(e))?;
        
        // In real implementation, we would apply the resolution to the actual file
        Ok(())
    }
}
--- END FILE: apps\pds\src\network_handler.rs ---


--- START FILE: apps\pds\src\storage.rs ---
//! Network storage interface

use crate::metadata::{FileMetadata, ChunkMetadata};

/// Comprehensive error type for network operations
#[derive(Debug)]
pub enum NetworkError {
    StorageError(String),
    NotFound,
    ConnectionError,
    SerializationError,
    VerificationFailed(String),
    DecryptionError(String),
    StorageFull,
    InvalidData,
    // Add more as needed
}

impl std::fmt::Display for NetworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            NetworkError::StorageError(msg) => write!(f, "Storage error: {}", msg),
            NetworkError::NotFound => write!(f, "Resource not found"),
            NetworkError::ConnectionError => write!(f, "Connection error"),
            NetworkError::SerializationError => write!(f, "Serialization error"),
            NetworkError::VerificationFailed(msg) => write!(f, "Verification failed: {}", msg),
            NetworkError::DecryptionError(msg) => write!(f, "Decryption error: {}", msg),
            NetworkError::StorageFull => write!(f, "Storage full"),
            NetworkError::InvalidData => write!(f, "Invalid data"),
        }
    }
}

/// Network trait extension for storage operations
pub trait Network {
    /// Store a file's metadata in the network
    async fn store_metadata(&mut self, metadata: &FileMetadata) -> Result<(), NetworkError>;
    
    /// Retrieve a file's metadata by content address
    async fn get_metadata(&self, content_address: &str) -> Result<FileMetadata, NetworkError>;
    
    /// Store an encrypted chunk in the network using content address
    async fn store_chunk(&mut self, content_address: &str, chunk: &[u8]) -> Result<(), NetworkError>;
    
    /// Retrieve a chunk by its content address
    async fn get_chunk(&self, content_address: &str) -> Result<Vec<u8>, NetworkError>;
}
--- END FILE: apps\pds\src\storage.rs ---


--- START FILE: libs\cpc-core\Cargo.toml ---
[package]
name = "cpc-core"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = { version = "0.13", features = ["dynamic", "render", "png", "gltf"] }
libp2p = { version = "0.53", features = ["tcp-tokio", "websocket"] }
merkle-cbt = "3.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
jni = { version = "0.21", optional = true }  # For Android
winit = { version = "0.29", features = ["android-native-activity"] }
image = "0.24"  # For saving PNG thumbnails
anyhow = "1.0"   # For error handling

[build-dependencies]

[features]
default = []
android = ["jni", "winit/android-native-activity"]

# Activate Android features by default when building for Android
[target.'cfg(target_os = "android")'.dependencies]
bevy = { version = "0.13", features = ["dynamic", "android", "render", "png", "gltf"] }
libp2p = { version = "0.53", features = ["tcp-tokio", "websocket", "android"] }
--- END FILE: libs\cpc-core\Cargo.toml ---


--- START FILE: libs\cpc-core\src\android_lifecycle.rs ---
use jni::{objects::JClass, JNIEnv};
use crate::bevy::android::get_bevy_app;
use crate::p2p::android::pause_p2p_network;
use crate::p2p::android::resume_p2p_network;

static IS_PAUSED: std::sync::atomic::AtomicBool = std::sync::atomic::AtomicBool::new(false);

#[no_mangle]
pub extern "system" fn Java_com_cpc_CPCCore_onCreate(
    _env: JNIEnv,
    _: JClass
) {
    println!("CPC Core initialized on Android");
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_CPCCore_onPause(
    _env: JNIEnv,
    _: JClass
) {
    IS_PAUSED.store(true, std::sync::atomic::Ordering::SeqCst);
    println!("CPC Core paused");
    
    // Suspend Bevy engine
    if let Some(app) = unsafe { get_bevy_app() } {
        // Clean up textures to reduce memory pressure
        println!("Cleaning up Bevy textures");
        // In a real implementation, we'd call app.world.resource_mut::<Assets<Texture>>().clear();
    }
    
    // Pause P2P networking
    pause_p2p_network();
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_CPCCore_onResume(
    _env: JNIEnv,
    _: JClass
) {
    IS_PAUSED.store(false, std::sync::atomic::Ordering::SeqCst);
    println!("CPC Core resumed");
    
    // Resume P2P networking
    resume_p2p_network();
    
    // Resume Bevy engine
    if let Some(app) = unsafe { get_bevy_app() } {
        println!("Resuming Bevy engine");
        // In a real implementation, we'd reload necessary textures
    }
}
--- END FILE: libs\cpc-core\src\android_lifecycle.rs ---


--- START FILE: libs\cpc-core\src\lib.rs ---
pub mod bridge;
pub mod p2p;
pub mod bevy;
pub mod native;
pub mod thumbnail_ffi;

#[cfg(target_os = "android")]
mod android_lifecycle;

// Re-export android lifecycle functions
#[cfg(target_os = "android")]
pub use android_lifecycle::*;
--- END FILE: libs\cpc-core\src\lib.rs ---


--- START FILE: libs\cpc-core\src\thumbnail_ffi.rs ---
use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use anyhow::{Context, Result};
use bevy::prelude::*;
use bevy::render::camera::RenderTarget;
use bevy::render::view::RenderLayers;
use bevy::window::PrimaryWindow;
use bevy::asset::LoadState;
use bevy::scene::ScenePlugin;
use bevy::gltf::GltfPlugin;
use std::path::Path;

#[cfg_attr(target_os = "android", jni::jni_export)]
#[no_mangle]
pub extern "C" fn generate_model_thumbnail(
    model_path: *const c_char,
    output_path: *const c_char,
    size: u32
) -> *const c_char {
    let model_path_str = unsafe { CStr::from_ptr(model_path).to_string_lossy().to_string() };
    let output_path_str = unsafe { CStr::from_ptr(output_path).to_string_lossy().to_string() };

    match generate_thumbnail_inner(&model_path_str, &output_path_str, size) {
        Ok(()) => std::ptr::null(),
        Err(e) => {
            let error_str = e.to_string();
            let c_str = CString::new(error_str).unwrap_or_else(|_| CString::new("Unknown error").unwrap());
            c_str.into_raw()
        }
    }
}

fn generate_thumbnail_inner(model_path: &str, output_path: &str, size: u32) -> Result<()> {
    let mut app = App::new();

    // Set up minimal plugins
    app.add_plugins(MinimalPlugins);
    app.add_plugins(AssetPlugin::default());
    app.add_plugins(bevy::render::RenderPlugin::default());
    app.add_plugins(ScenePlugin);
    app.add_plugins(GltfPlugin);

    // Configure render settings
    app.insert_resource(Msaa::Off);
    app.insert_resource(ClearColor(Color::BLACK));

    // Load the model
    let model_handle: Handle<Scene> = app.world.resource_scope(|world, asset_server: Mut<AssetServer>| {
        asset_server.load(model_path)
    });

    // Set up camera
    let mut camera = Camera3dBundle {
        camera: Camera {
            order: 1,
            ..default()
        },
        transform: Transform::from_xyz(0.0, 0.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    };
    camera.camera.hdr = true;
    app.world.spawn(camera);

    // Set up lighting
    app.world.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            illuminance: 10000.0,
            shadows_enabled: true,
            ..default()
        },
        transform: Transform::from_xyz(0.0, 5.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    // Run systems until model is loaded
    while app.world.resource::<AssetServer>().get_load_state(&model_handle) != LoadState::Loaded {
        app.update();
    }

    // Spawn the model
    app.world.spawn(SceneBundle {
        scene: model_handle,
        ..default()
    });

    // Render and capture
    // Note: Actual rendering capture would go here
    // This is a placeholder implementation
    
    // Save a placeholder image
    let image = image::RgbaImage::new(size, size);
    image.save(output_path)
        .with_context(|| format!("Failed to save thumbnail to {}", output_path))?;

    Ok(())
}
--- END FILE: libs\cpc-core\src\thumbnail_ffi.rs ---


--- START FILE: libs\cpc-core\src\bevy\android.rs ---
use jni::{objects::JObject, sys::jlong, JNIEnv};
use bevy::prelude::*;
use winit::platform::android::EventLoopExtAndroid;
use crate::bridge::android::ANDROID_ENGINE_BRIDGE;

#[no_mangle]
pub extern "system" fn Java_com_cpc_BevyActivity_create_engine(
    env: JNIEnv,
    _: JClass,
    surface: JObject
) -> jlong {
    // Initialize Bevy and pass native surface
    let mut app = App::new();
    
    // Configure Bevy for Android
    app.add_plugins(DefaultPlugins
        .set(WindowPlugin {
            primary_window: Some(Window {
                canvas: Some(surface.into_raw() as _),
                ..default()
            }),
            ..default()
        })
    );
    
    // Register Android engine bridge
    app.insert_resource(ANDROID_ENGINE_BRIDGE);
    
    // Store the app in a Box and return as raw pointer
    Box::into_raw(Box::new(app)) as jlong
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_BevyActivity_run_engine(
    _: JNIEnv,
    _: JClass,
    engine_ptr: jlong
) {
    let app = unsafe { &mut *(engine_ptr as *mut App) };
    app.run();
}

// Demo system for native UI integration
pub fn native_ui_demo_system(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut materials: ResMut<Assets<ColorMaterial>>,
    engine_bridge: Res<AndroidEngineBridge>
) {
    // Example: Spawn native UI texture as sprite
    // This would be replaced with actual texture from bridge
    commands.spawn(SpriteBundle {
        material: materials.add(ColorMaterial::color(Color::RED)),
        sprite: Sprite::new(Vec2::new(100.0, 100.0)),
        ..Default::default()
    });
    
    // Example: Send game event to native UI
    engine_bridge.send_game_event(
        "player_moved",
        serde_json::json!({"x": 10, "y": 20})
    );
}
--- END FILE: libs\cpc-core\src\bevy\android.rs ---


--- START FILE: libs\cpc-core\src\bevy\mod.rs ---
use bevy::prelude::*;
use crate::bridge::{EngineBridge, TextureData};

// Platform-specific modules
#[cfg(target_os = "android")]
pub mod android;

pub struct CpcBevyPlugin;

impl Plugin for CpcBevyPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_engine_messages);
        
        // Add our UI plugin
        app.add_plugin(CpcUIPlugin);
    }
}

fn handle_engine_messages(
    mut commands: Commands,
    mut game_events: EventReader<GameEvent>,
    mut system_commands: EventReader<SystemCommand>,
    asset_server: Res<AssetServer>,
) {
    for event in game_events.iter() {
        // Handle game events from native
        println!("Received game event: {:?}", event);
    }
    
    for command in system_commands.iter() {
        // Handle system commands from native
        println!("Executing system command: {} with params {:?}", command.command, command.parameters);
    }
}

/// Renders native UI components and returns them as textures
#[cfg(target_os = "android")]
pub fn render_ui(component_name: &str, props: serde_json::Value) -> Option<Texture> {
    // Delegate to Android-specific implementation
    android::render_ui_component(component_name, props)
}

pub struct CpcUIPlugin;

impl Plugin for CpcUIPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_ui_requests);
    }
}

fn handle_ui_requests(
    mut commands: Commands,
    mut ui_requests: EventReader<UIRequest>,
    asset_server: Res<AssetServer>,
) {
    for request in ui_requests.iter() {
        if let Some(texture) = render_ui(&request.component_name, request.props.clone()) {
            commands.spawn(SpriteBundle {
                texture: asset_server.add(texture),
                transform: Transform::from_xyz(request.position.x, request.position.y, 0.0),
                ..default()
            });
        }
    }
}

#[derive(Event)]
pub struct UIRequest {
    pub component_name: String,
    pub props: serde_json::Value,
    pub position: Vec2,
}

#[derive(Event)]
pub struct GameEvent {
    pub event_type: String,
    pub data: serde_json::Value,
}

#[derive(Event)]
pub struct SystemCommand {
    pub command: String,
    pub parameters: Vec<String>,
}

// Android-specific implementation
#[cfg(target_os = "android")]
impl CpcBevyPlugin {
    pub fn create_android_engine(surface: *mut std::ffi::c_void) -> *mut App {
        let mut app = App::new();
        
        // Configure Bevy for Android
        app.add_plugins(DefaultPlugins
            .set(WindowPlugin {
                primary_window: Some(Window {
                    canvas: Some(surface as _),
                    ..default()
                }),
                ..default()
            })
        );
        
        // Add our plugins
        app.add_plugin(Self);
        
        Box::into_raw(Box::new(app))
    }
    
    pub fn init_surface(&self, surface: *mut c_void) {
        // Reconfigure Bevy with the new surface
        let mut app = self.app.lock().unwrap();
        app.world.resource_mut::<WindowDescriptor>().canvas = Some(surface as _);
    }
}

#[cfg(target_os = "android")]
pub fn render_ui_component(component_name: &str, props: serde_json::Value) -> Option<Texture> {
    // This will call into the Android-specific bridge
    if let Some(texture_data) = crate::bridge::android::request_ui_texture(component_name, props) {
        Some(Texture::new(
            Extent3d {
                width: texture_data.width,
                height: texture_data.height,
                depth_or_array_layers: 1,
            },
            TextureDimension::D2,
            texture_data.data,
            TextureFormat::Rgba8UnormSrgb,
        ))
    } else {
        None
    }
}
--- END FILE: libs\cpc-core\src\bevy\mod.rs ---


--- START FILE: libs\cpc-core\src\bridge\android.rs ---
use super::*;
use jni::{objects::JObject, sys::jobject, JNIEnv};
use crate::bevy::BevyEngine;
use crate::events::{EventSystem, P2PEvent, UIEvent};

// EngineBridge implementation for Android
pub struct AndroidEngineBridge;

impl EngineBridge for AndroidEngineBridge {
    fn handle_system_command(&self, command: &str, params: &[String]) {
        // Forward system commands to Bevy
        let engine = BevyEngine::get_instance();
        engine.handle_system_command(command, params);
    }

    fn receive_texture(&self, texture: TextureData) {
        // Handle texture received from native UI
        let engine = BevyEngine::get_instance();
        engine.receive_texture(texture);
    }
}

// Global engine bridge instance
pub static ANDROID_ENGINE_BRIDGE: AndroidEngineBridge = AndroidEngineBridge;

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_requestUI(
    env: JNIEnv,
    _: JClass,
    component: JString,
    props: JString
) -> jobject {
    // Convert Java strings to Rust types
    let component_str: String = env.get_string(component).unwrap().into();
    let props_str: String = env.get_string(props).unwrap().into();
    let props_value: serde_json::Value = serde_json::from_str(&props_str).unwrap();
    
    // Get Bevy engine instance and render UI
    let engine = BevyEngine::get_instance();
    let texture = engine.render_ui(&component_str, props_value);
    
    // Convert TextureData to Android Bitmap
    let bitmap_class = env.find_class("android/graphics/Bitmap").unwrap();
    let create_bitmap = env.get_static_method_id(
        bitmap_class,
        "createBitmap",
        "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;"
    ).unwrap();
    
    let config_class = env.find_class("android/graphics/Bitmap$Config").unwrap();
    let argb_8888 = env.get_static_field_id(
        config_class,
        "ARGB_8888",
        "Landroid/graphics/Bitmap$Config;"
    ).unwrap();
    let config = env.get_static_field(config_class, argb_8888).unwrap();
    
    let bitmap = env.call_static_method(
        bitmap_class,
        create_bitmap,
        &[
            (texture.width as i32).into(),
            (texture.height as i32).into(),
            config.into()
        ]
    ).unwrap().l().unwrap();
    
    // Copy pixel data to Bitmap
    let pixel_buffer = env.new_direct_byte_buffer(texture.data.as_slice()).unwrap();
    let _ = env.call_method(
        bitmap,
        "copyPixelsFromBuffer",
        "(Ljava/nio/Buffer;)V",
        &[pixel_buffer.into()]
    );
    
    bitmap.into_raw()
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_forwardUIEvent(
    env: JNIEnv,
    _: JClass,
    event_json: JString
) {
    let event_str: String = env.get_string(event_json).unwrap().into();
    let event: UIEvent = serde_json::from_str(&event_str).unwrap();
    
    // Convert to P2P event format
    let p2p_event = P2PEvent::from_ui_event(event);
    
    // Send to event system
    let event_system = EventSystem::get_instance();
    event_system.handle_incoming_event(p2p_event);
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_sendGameEvent(
    env: JNIEnv,
    _: JClass,
    event_type: JString,
    data: JString
) {
    // Convert Java strings to Rust types
    let event_type_str: String = env.get_string(event_type).unwrap().into();
    let data_str: String = env.get_string(data).unwrap().into();
    let data_value: serde_json::Value = serde_json::from_str(&data_str).unwrap();
    
    // Create UIEvent
    let ui_event = UIEvent {
        component: "game".to_string(),
        action: event_type_str,
        data: data_value,
    };
    
    // Convert to P2P event format
    let p2p_event = P2PEvent::from_ui_event(ui_event);
    
    // Send to event system
    let event_system = EventSystem::get_instance();
    event_system.handle_incoming_event(p2p_event);
}

#[no_mangle]
#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_initBevySurface(
    env: JNIEnv,
    _: JClass,
    surface: jobject
) {
    // Get native surface pointer
    let surface_ptr = env.get_direct_buffer_address(surface).unwrap();
    let engine = BevyEngine::get_instance();
    engine.init_surface(surface_ptr as *mut c_void);
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_sendTextureToEngine(
    env: JNIEnv,
    _: JClass,
    bitmap: JObject
) {
    // Get bitmap info
    let width = env.call_method(bitmap, "getWidth", "()I", &[]).unwrap().i().unwrap();
    let height = env.call_method(bitmap, "getHeight", "()I", &[]).unwrap().i().unwrap();
    
    // Get bitmap pixels
    let buffer = env.new_direct_byte_buffer(&mut vec![0u8; (width * height * 4) as usize]).unwrap();
    env.call_method(bitmap, "copyPixelsToBuffer", "(Ljava/nio/Buffer;)V", &[buffer.into()]).unwrap();
    
    // Create TextureData
    let texture = TextureData {
        width: width as u32,
        height: height as u32,
        data: buffer.into_raw().as_slice().to_vec(),
    };
    
    // Send to engine
    ANDROID_ENGINE_BRIDGE.receive_texture(texture);
}
--- END FILE: libs\cpc-core\src\bridge\android.rs ---


--- START FILE: libs\cpc-core\src\bridge\mod.rs ---
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub enum BridgeMessage {
    RenderUI {
        component: String,
        props: serde_json::Value,
    },
    GameEvent {
        event_type: String,
        data: serde_json::Value,
    },
    SystemCommand {
        command: String,
        parameters: Vec<String>,
    },
}

#[derive(Serialize, Deserialize)]
pub struct TextureData {
    pub width: u32,
    pub height: u32,
    pub data: Vec<u8>, // RGBA format
}

pub trait NativeBridge {
    fn request_ui(&self, component: &str, props: serde_json::Value) -> TextureData;
    fn send_game_event(&self, event_type: &str, data: serde_json::Value);
}

pub trait EngineBridge {
    fn handle_system_command(&self, command: &str, params: &[String]);
    fn receive_texture(&self, texture: TextureData);
}

// Platform-specific modules
#[cfg(target_os = "android")]
pub mod android;

#[cfg(target_family = "wasm")]
pub mod web;

#[cfg(not(any(target_os = "android", target_family = "wasm")))]
pub mod desktop;
--- END FILE: libs\cpc-core\src\bridge\mod.rs ---


--- START FILE: libs\cpc-core\src\events\mod.rs ---
use std::collections::{BTreeMap, BinaryHeap};
use std::sync::{Arc, Mutex};
use once_cell::sync::OnceCell;
use prost::Message;
use uuid::Uuid;
use crate::p2p::NetworkHandler;

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum EventType {
    UIInteraction,
    GameStateUpdate,
    NetworkCommand,
}

use crate::p2p::reconciliation::HybridTimestamp;

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct P2PEvent {
    pub event_id: String,
    pub timestamp: HybridTimestamp,
    pub event_type: EventType,
    pub source_device: String,
    pub payload: Vec<u8>,
    pub vector_clock: BTreeMap<String, u64>,
    pub conflict_flag: bool,
}

impl P2PEvent {
    pub fn from_ui_event(event: UIEvent) -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
            
        P2PEvent {
            event_id: Uuid::new_v4().to_string(),
            timestamp: (now, 0), // (wall time, logical time)
            event_type: EventType::UIInteraction,
            source_device: "android".to_string(),
            payload: serde_json::to_vec(&event).unwrap(),
            vector_clock: BTreeMap::new(),
            conflict_flag: false,
        }
    }
    
    pub fn mark_conflict(&mut self) {
        self.conflict_flag = true;
    }
}

impl Ord for P2PEvent {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        // Prioritize UI interactions highest
        match (&self.event_type, &other.event_type) {
            (EventType::UIInteraction, _) => std::cmp::Ordering::Greater,
            (_, EventType::UIInteraction) => std::cmp::Ordering::Less,
            _ => self.timestamp.cmp(&other.timestamp),
        }
    }
}

impl PartialOrd for P2PEvent {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

pub struct EventSystem {
    vector_clock: BTreeMap<String, u64>,
    event_queue: BinaryHeap<P2PEvent>,
    network_handler: Arc<NetworkHandler>,
}

// Global singleton instance
static EVENT_SYSTEM_INSTANCE: OnceCell<Arc<Mutex<EventSystem>>> = OnceCell::new();

impl EventSystem {
    pub fn get_instance(network_handler: Arc<NetworkHandler>) -> Arc<Mutex<Self>> {
        EVENT_SYSTEM_INSTANCE.get_or_init(|| {
            Arc::new(Mutex::new(EventSystem::new(network_handler)))
        }).clone()
    }

    fn new(network_handler: Arc<NetworkHandler>) -> Self {
        EventSystem {
            vector_clock: BTreeMap::new(),
            event_queue: BinaryHeap::new(),
            network_handler,
        }
    }

    pub fn handle_incoming_event(&mut self, event: P2PEvent) {
        // Apply vector clock logic
        self.vector_clock.entry(event.source_device.clone())
            .and_modify(|e| *e = (*e).max(event.vector_clock[&event.source_device]))
            .or_insert(event.vector_clock[&event.source_device]);
        
        // Add to prioritized queue
        self.event_queue.push(event);
    }

    pub fn broadcast_event(&self, event: P2PEvent) {
        // Prioritize based on event type
        let priority = match event.event_type {
            EventType::UIInteraction => 0,
            EventType::GameStateUpdate => 1,
            EventType::NetworkCommand => 2,
        };
        
        // Serialize with protobuf
        let mut buf = Vec::new();
        event.encode(&mut buf).unwrap();
        
        // Broadcast to peers using the unified NetworkHandler
        self.network_handler.broadcast_event(&buf, priority);
    }

    pub fn resolve_conflicts(&mut self) {
        // Conflict resolution logic would go here
        // For now, we'll just process events in order
        while let Some(event) = self.event_queue.pop() {
            // Process event
        }
    }
}

pub fn compress_event(event: &P2PEvent) -> Vec<u8> {
    // Simple compression - use in production would use a real compression library
    let mut compressed = Vec::new();
    compressed.extend_from_slice(&event.event_id.as_bytes());
    compressed.extend_from_slice(&event.timestamp.to_be_bytes());
    compressed
}

// UIEvent struct needed for Android bridge
#[derive(serde::Serialize, serde::Deserialize)]
pub struct UIEvent {
    pub component: String,
    pub action: String,
    pub data: serde_json::Value,
}
--- END FILE: libs\cpc-core\src\events\mod.rs ---


--- START FILE: libs\cpc-core\src\p2p\android.rs ---
use jni::{JNIEnv, objects::JClass};
use crate::p2p::NetworkHandler;
use crate::events::EventSystem;

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_startP2PService(
    env: JNIEnv,
    _: JClass,
    config: JString
) {
    let config_str: String = env.get_string(config).unwrap().into();
    // Get network handler instance
    let network_handler = NetworkHandler::get_instance(config_str.clone());
    
    // Initialize event system with network handler
    let _event_system = EventSystem::get_instance(network_handler.clone());
    
    // Start the network
    network_handler.start();
}

#[no_mangle]
pub extern "system" fn Java_com_cpc_NativeBridge_stopP2PService(
    _env: JNIEnv,
    _: JClass
) {
    // Stop P2P service - implementation will be added later
}
--- END FILE: libs\cpc-core\src\p2p\android.rs ---


--- START FILE: libs\cpc-core\src\p2p\mod.rs ---
pub mod network;
pub mod storage;
pub mod sync;
pub mod events;
pub mod reconciliation;

// Platform-specific modules
#[cfg(target_os = "android")]
pub mod android;

// Re-export key components
pub use network::NetworkHandler;
pub use storage::MetadataStore;
pub use sync::SynchronizationManager;
pub use events::{EventSystem, P2PEvent};
--- END FILE: libs\cpc-core\src\p2p\mod.rs ---


--- START FILE: libs\cpc-core\src\p2p\network.rs ---
use rust_libp2p::{Swarm, Multiaddr, identity, PeerId, futures::StreamExt};
use rust_libp2p::ping::{Ping, PingConfig};
use rust_libp2p::swarm::{SwarmEvent, dial_opts::DialOpts};
use std::sync::{Arc, Mutex};
use once_cell::sync::OnceCell;
use crate::events::compress_event;

pub struct NetworkHandler {
    swarm: Arc<Mutex<Swarm<Ping>>>,
    config: String,
}

static NETWORK_HANDLER_INSTANCE: OnceCell<Arc<NetworkHandler>> = OnceCell::new();

impl NetworkHandler {
    pub fn get_instance(config: String) -> Arc<Self> {
        NETWORK_HANDLER_INSTANCE.get_or_init(|| {
            Arc::new(NetworkHandler::new(config.clone()))
        }).clone()
    }

    fn new(config: String) -> Self {
        // Create libp2p identity
        let local_key = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());
        
        // Create swarm
        let transport = rust_libp2p::development_transport(local_key).unwrap();
        let behaviour = Ping::new(PingConfig::new().with_keep_alive(true));
        let swarm = Swarm::new(transport, behaviour, local_peer_id);

        NetworkHandler {
            swarm: Arc::new(Mutex::new(swarm)),
            config,
        }
    }

    pub fn broadcast_event(&self, event: &[u8], priority: u8) {
        let compressed = compress_event(event);
        let mut swarm = self.swarm.lock().unwrap();
        
        // Get connected peers
        let peers = swarm.connected_peers().collect::<Vec<_>>();
        
        for peer_id in peers {
            if let Err(e) = swarm.send_event(&peer_id, compressed.clone()) {
                log::error!("Failed to send event to {}: {:?}", peer_id, e);
            }
        }
    }

    pub fn connected_peers(&self) -> Vec<PeerId> {
        let swarm = self.swarm.lock().unwrap();
        swarm.connected_peers().collect()
    }

    pub fn start(&self) {
        let config: serde_json::Value = serde_json::from_str(&self.config).unwrap();
        let mut swarm = self.swarm.lock().unwrap();
        
        // Parse multiaddr from config
        if let Some(addr_str) = config["bootstrap_node"].as_str() {
            if let Ok(addr) = addr_str.parse::<Multiaddr>() {
                if let Err(e) = swarm.dial(addr) {
                    log::error!("Failed to dial bootstrap node: {:?}", e);
                } else {
                    log::info!("Dialed bootstrap node: {}", addr_str);
                }
            }
        }
    }
}
--- END FILE: libs\cpc-core\src\p2p\network.rs ---


--- START FILE: libs\cpc-core\src\p2p\reconciliation.rs ---
use std::collections::BTreeMap;
use crate::events::P2PEvent;
use automerge::AutoCommit;
use thiserror::Error;

pub type VectorClock = BTreeMap<String, u64>;
pub type HybridTimestamp = (u64, u64); // (wall clock time, logical time)

#[derive(Error, Debug)]
pub enum ReconciliationError {
    #[error("Merge conflict detected")]
    MergeConflict,
    #[error("Event dependency not satisfied")]
    DependencyNotSatisfied,
    #[error("Network error: {0}")]
    NetworkError(String),
}

pub struct ReconciliationEngine {
    vector_clock: VectorClock,
    state: AutoCommit,
    pending_events: BTreeMap<HybridTimestamp, P2PEvent>,
}

impl ReconciliationEngine {
    pub fn new() -> Self {
        ReconciliationEngine {
            vector_clock: VectorClock::new(),
            state: AutoCommit::new(),
            pending_events: BTreeMap::new(),
        }
    }

    pub fn apply_event(&mut self, event: P2PEvent) -> Result<(), ReconciliationError> {
        // Check if event is ready based on vector clock
        if !self.is_event_ready(&event) {
            self.pending_events.insert(event.timestamp, event);
            return Ok(());
        }
        
        // Apply conflict-free merge
        if let Err(_) = self.state.merge(event.payload) {
            return Err(ReconciliationError::MergeConflict);
        }
        
        // Update vector clock
        self.vector_clock
            .entry(event.source_device.clone())
            .and_modify(|v| *v = event.timestamp.1)
            .or_insert(event.timestamp.1);
        
        // Process any pending events that became ready
        self.process_pending_events();
        Ok(())
    }
    
    fn is_event_ready(&self, event: &P2PEvent) -> bool {
        // Check if all dependencies in vector clock are satisfied
        for (peer, &remote_time) in &event.vector_clock {
            let local_time = self.vector_clock.get(peer).cloned().unwrap_or(0);
            if remote_time > local_time {
                return false;
            }
        }
        true
    }
    
    fn process_pending_events(&mut self) {
        let mut ready_events = Vec::new();
        
        // Collect ready events
        for (ts, event) in self.pending_events.iter() {
            if self.is_event_ready(event) {
                ready_events.push(*ts);
            }
        }
        
        // Apply ready events
        for ts in ready_events {
            if let Some(event) = self.pending_events.remove(&ts) {
                let _ = self.apply_event(event);
            }
        }
    }
    
    pub fn reconcile_with_peer(&mut self, peer_id: &str) -> Result<(), ReconciliationError> {
        // Get our state delta since last sync
        let last_sync_time = self.vector_clock.get(peer_id).cloned().unwrap_or(0);
        let state_delta = self.state.get_delta_since(last_sync_time);
        
        // Send reconciliation request (implementation depends on network layer)
        // This would typically be handled by the network module
        // network_handler.send_reconciliation_request(peer_id, state_delta);
        
        // For now, we'll simulate successful reconciliation
        self.vector_clock
            .entry(peer_id.to_string())
            .and_modify(|v| *v = last_sync_time + 1)
            .or_insert(1);
            
        Ok(())
    }
    
    pub fn handle_reconciliation_request(
        &mut self, 
        peer_id: &str, 
        delta: Vec<u8>
    ) -> Result<Vec<u8>, ReconciliationError> {
        // Merge incoming delta
        if let Err(_) = self.state.merge(delta) {
            return Err(ReconciliationError::MergeConflict);
        }
        
        // Prepare our state delta for response
        let peer_last_time = self.vector_clock.get(peer_id).cloned().unwrap_or(0);
        let our_delta = self.state.get_delta_since(peer_last_time);
        
        Ok(our_delta)
    }
}
--- END FILE: libs\cpc-core\src\p2p\reconciliation.rs ---


--- START FILE: libs\cpc-core\src\p2p\sync.rs ---
use crate::events::P2PEvent;
use crate::p2p::reconciliation::{ReconciliationEngine, ReconciliationError};

/// Manages the overall synchronization process for a peer.
/// It owns the ReconciliationEngine and orchestrates interactions
/// with the network and the local state.
pub struct SynchronizationManager {
    reconciliation_engine: ReconciliationEngine,
}

impl SynchronizationManager {
    /// Creates a new SynchronizationManager.
    pub fn new() -> Self {
        Self {
            reconciliation_engine: ReconciliationEngine::new(),
        }
    }

    /// Entry point for handling an incoming event from the network.
    pub fn handle_incoming_event(&mut self, event: P2PEvent) -> Result<(), ReconciliationError> {
        self.reconciliation_engine.apply_event(event)
    }
    
    /// Initiates reconciliation with a specific peer
    pub fn reconcile_with_peer(&mut self, peer_id: &str) -> Result<(), ReconciliationError> {
        self.reconciliation_engine.reconcile_with_peer(peer_id)
    }
    
    /// Handles a reconciliation request from a peer
    pub fn handle_reconciliation_request(
        &mut self,
        peer_id: &str,
        delta: Vec<u8>
    ) -> Result<Vec<u8>, ReconciliationError> {
        self.reconciliation_engine.handle_reconciliation_request(peer_id, delta)
    }
}

impl Default for SynchronizationManager {
    fn default() -> Self {
        Self::new()
    }
}
--- END FILE: libs\cpc-core\src\p2p\sync.rs ---


--- START FILE: libs\cpc-net\build.rs ---
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::configure()
        .build_server(true)
        .out_dir("src/grpc") // output directory
        .compile(
            &["protos/internal.proto"],
            &["protos"], // proto root
        )?;
    Ok(())
}
--- END FILE: libs\cpc-net\build.rs ---


--- START FILE: libs\cpc-net\Cargo.toml ---
[package]
name = "cpc-lib"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
libp2p-core = { version = "0.41.0", features = ["noise"] }
libp2p-kad = { version = "0.43.0", features = ["metrics"] }
libp2p-bitswap = { version = "0.44.0" }
libp2p-gossipsub = "0.47.0"
libp2p-metrics = "0.16.0"
libp2p-tcp = "0.42.0"
libp2p-websocket = "0.45.0"
libp2p-quic = "0.5.0"
blake3 = "1.5.0"
secp256k1 = "0.27.0"
x25519-dalek = "2.0.0"
lru = "0.11.0"
metrics = "0.21.0"
rand = "0.8.5"
tonic = "0.10"
prost = "0.12"
tokio = { version = "1.0", features = ["macros", "rt-multi-thread"] }
prost-types = "0.12"

[build-dependencies]
tonic-build = "0.10"
--- END FILE: libs\cpc-net\Cargo.toml ---


--- START FILE: libs\cpc-net\src\crypto.rs ---
//! Cryptographic operations for Cooperative Peer Cloud
//!
//! Provides:
//! - Key pair generation (ed25519 for signing, x25519 for encryption)
//! - Content hashing (BLAKE3)
//! - Noise protocol implementation for encrypted communications
//!
//! Example usage:
//! ```
//! use cpc_lib::crypto::{KeyPair, hash_content, NoiseSession};
//!
//! // Generate key pairs
//! let signing_keys = KeyPair::generate_ed25519();
//! let encryption_keys = KeyPair::generate_x25519();
//!
//! // Hash content
//! let data = b"Hello, world!";
//! let hash = hash_content(data);
//!
//! // Set up Noise session
//! let mut session = NoiseSession::new_initiator(&encryption_keys);
//! ```

use blake3;
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use x25519_dalek::{StaticSecret, PublicKey as X25519PublicKey};
use libp2p_core::identity::{self, Keypair, ed25519};
use libp2p_core::noise::{NoiseConfig, Keypair as NoiseKeypair, X25519Spec};
use rand::rngs::OsRng;

/// Represents a cryptographic key pair
pub struct KeyPair {
    pub secret: Vec<u8>,
    pub public: Vec<u8>,
}

impl KeyPair {
    /// Generate ED25519 key pair for signing
    pub fn generate_ed25519() -> Self {
        let keypair = identity::Keypair::generate_ed25519();
        KeyPair {
            secret: keypair.secret().as_ref().to_vec(),
            public: keypair.public().encode_protobuf(),
        }
    }

    /// Generate X25519 key pair for encryption
    pub fn generate_x25519() -> Self {
        let secret = StaticSecret::new(OsRng);
        let public = X25519PublicKey::from(&secret);
        KeyPair {
            secret: secret.to_bytes().to_vec(),
            public: public.as_bytes().to_vec(),
        }
    }
}

/// Hash content using BLAKE3
pub fn hash_content(data: &[u8]) -> [u8; 32] {
    blake3::hash(data).into()
}

/// Noise protocol session for encrypted communications
pub struct NoiseSession {
    inner: libp2p_core::noise::NoiseConfig<X25519Spec>,
}

impl NoiseSession {
    /// Create a new Noise session as initiator
    pub fn new_initiator(keys: &KeyPair) -> Self {
        let secret = StaticSecret::from(keys.secret.as_slice().try_into().unwrap());
        let keypair = NoiseKeypair::from(secret);
        let noise = NoiseConfig::xx(keypair).into_authenticated();
        NoiseSession { inner: noise }
    }

    /// Create a new Noise session as responder
    pub fn new_responder(keys: &KeyPair) -> Self {
        let secret = StaticSecret::from(keys.secret.as_slice().try_into().unwrap());
        let keypair = NoiseKeypair::from(secret);
        let noise = NoiseConfig::xx(keypair).into_authenticated();
        NoiseSession { inner: noise }
    }
}
--- END FILE: libs\cpc-net\src\crypto.rs ---


--- START FILE: libs\cpc-net\src\lib.rs ---
//! Shared library for Cooperative Peer Cloud components
//!
//! Provides core functionality for:
//! - Cryptographic operations (key generation, hashing, encryption)
//! - Network abstractions (peer discovery, transport, protocols)
//! - Content-addressable storage with metrics
//!
//! ## Example
//! ```
//! use cpc_lib::{crypto, net, storage};
//!
//! // Generate cryptographic keys
//! let signing_keys = crypto::KeyPair::generate_ed25519();
//! let encryption_keys = crypto::KeyPair::generate_x25519();
//!
//! // Set up network
//! let mut network = net::NetworkBuilder::new()
//!     .with_tcp()
//!     .with_quic()
//!     .build();
//!
//! // Initialize storage
//! let mut storage = storage::LruStorage::new(1024 * 1024 * 100); // 100 MB
//! ```

pub mod crypto;
pub mod net;
pub mod storage;

// Re-export key types from modules
pub use crypto::{KeyPair, NoiseSession, hash_content};
pub use net::{NetworkBuilder, Network, NetworkEvent};
pub use storage::{ContentStorage, LruStorage, StorageMetrics, StorageError};
--- END FILE: libs\cpc-net\src\lib.rs ---


--- START FILE: libs\cpc-net\src\net.rs ---
//! Network abstractions for Cooperative Peer Cloud
//!
//! Provides:
//! - Peer ID derivation
//! - Transport configuration (TCP/QUIC/WebSockets)
//! - Network behavior (Kademlia DHT, Gossipsub, Bitswap)
//! - Metrics collection
//!
//! Example usage:
//! ```
//! use cpc_lib::net::{NetworkBuilder, NetworkEvent};
//! use futures::stream::StreamExt;
//!
//! let mut network = NetworkBuilder::new()
//!     .with_tcp()
//!     .with_quic()
//!     .with_websocket()
//!     .with_kademlia()
//!     .with_gossipsub()
//!     .with_bitswap()
//!     .build();
//!
//! async {
//!     while let Some(event) = network.next().await {
//!         match event {
//!             NetworkEvent::PeerConnected(peer_id) => {
//!                 println!("Peer connected: {}", peer_id);
//!             }
//!             // Handle other events
//!             _ => {}
//!         }
//!     }
//! };
//! ```

use libp2p_core::identity;
use libp2p_core::PeerId;
use libp2p_core::transport::Boxed;
use libp2p_core::upgrade::Version;
use libp2p_tcp::TokioTcpConfig;
use libp2p_websocket::WsConfig;
use libp2p_quic::tokio::Transport as QuicTransport;
use libp2p_kad::{Kademlia, KademliaConfig, KademliaEvent, record::store::MemoryStore};
use libp2p_gossipsub::{Gossipsub, GossipsubConfig, GossipsubEvent, MessageId, Topic};
use libp2p_bitswap::{Bitswap, BitswapEvent};
use libp2p_metrics::Metrics;
use libp2p_swarm::{Swarm, SwarmEvent};
use futures::Stream;
use std::pin::Pin;
use std::task::{Context, Poll};

/// Network builder for configuring the P2P stack
pub struct NetworkBuilder {
    transports: Vec<Boxed<(PeerId, libp2p_core::muxing::StreamMuxerBox)>>,
    behaviors: Vec<Box<dyn libp2p_swarm::NetworkBehaviour>>,
    metrics: Option<Metrics>,
}

impl NetworkBuilder {
    /// Create a new network builder
    pub fn new() -> Self {
        NetworkBuilder {
            transports: Vec::new(),
            behaviors: Vec::new(),
            metrics: None,
        }
    }

    /// Add TCP transport
    pub fn with_tcp(mut self) -> Self {
        let tcp = TokioTcpConfig::new().nodelay(true).upgrade(Version::V1);
        self.transports.push(tcp.boxed());
        self
    }

    /// Add QUIC transport
    pub fn with_quic(mut self) -> Self {
        let keypair = identity::Keypair::generate_ed25519();
        let quic = QuicTransport::new(libp2p_quic::Config::new(&keypair));
        self.transports.push(quic.boxed());
        self
    }

    /// Add WebSocket transport
    pub fn with_websocket(mut self) -> Self {
        let tcp = TokioTcpConfig::new().nodelay(true);
        let ws = WsConfig::new(tcp);
        self.transports.push(ws.boxed());
        self
    }

    /// Add Kademlia DHT behavior
    pub fn with_kademlia(mut self) -> Self {
        let store = MemoryStore::new(PeerId::random());
        let mut config = KademliaConfig::default();
        config.set_query_timeout(std::time::Duration::from_secs(60));
        let kademlia = Kademlia::with_config(PeerId::random(), store, config);
        self.behaviors.push(Box::new(kademlia));
        self
    }

    /// Add Gossipsub behavior
    pub fn with_gossipsub(mut self) -> Self {
        let config = GossipsubConfig::default();
        let gossipsub = Gossipsub::new(PeerId::random(), config);
        self.behaviors.push(Box::new(gossipsub));
        self
    }

    /// Add Bitswap behavior
    pub fn with_bitswap(mut self) -> Self {
        let bitswap = Bitswap::new(PeerId::random());
        self.behaviors.push(Box::new(bitswap));
        self
    }

    /// Enable metrics collection
    pub fn with_metrics(mut self) -> Self {
        self.metrics = Some(Metrics::default());
        self
    }

    /// Build the network stack
    pub fn build(self) -> Network {
        let transport = self.transports.into_iter()
            .fold(None, |acc, t| match acc {
                Some(acc) => Some(acc.or_transport(t).boxed()),
                None => Some(t),
            })
            .expect("At least one transport must be configured");
        
        let behavior = self.behaviors.into_iter()
            .fold(None, |acc, b| match acc {
                Some(acc) => Some(acc.and_then(b)),
                None => Some(b),
            })
            .expect("At least one behavior must be configured");
        
        Network::new(transport, behavior, self.metrics)
    }
}

/// Represents the network stack
pub struct Network {
    swarm: Swarm<Box<dyn libp2p_swarm::NetworkBehaviour>>,
}

impl Network {
    fn new(
        transport: Boxed<(PeerId, libp2p_core::muxing::StreamMuxerBox)>,
        behavior: Box<dyn libp2p_swarm::NetworkBehaviour>,
        metrics: Option<Metrics>,
    ) -> Self {
        let swarm = Swarm::new(transport, behavior, PeerId::random());
        Network { swarm }
    }

    /// Get local peer ID
    pub fn local_peer_id(&self) -> &PeerId {
        self.swarm.local_peer_id()
    }
}

impl Stream for Network {
    type Item = NetworkEvent;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match Pin::new(&mut self.swarm).poll_next(cx) {
            Poll::Ready(Some(event)) => Poll::Ready(Some(NetworkEvent::from_swarm(event))),
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Pending => Poll::Pending,
        }
    }
}

/// Network events
pub enum NetworkEvent {
    PeerConnected(PeerId),
    PeerDisconnected(PeerId),
    KademliaEvent(KademliaEvent),
    GossipsubEvent(GossipsubEvent),
    BitswapEvent(BitswapEvent),
    MetricsUpdate,
    // Other event types
}

impl NetworkEvent {
    fn from_swarm(event: SwarmEvent<impl libp2p_swarm::NetworkBehaviourEvent>) -> Self {
        match event {
            SwarmEvent::Behaviour(event) => {
                // Convert behavior-specific events
                // Implementation details omitted for brevity
                NetworkEvent::KademliaEvent(KademliaEvent::RoutingUpdated { .. })
            }
            SwarmEvent::ConnectionEstablished { peer_id, .. } => {
                NetworkEvent::PeerConnected(peer_id)
            }
            SwarmEvent::ConnectionClosed { peer_id, .. } => {
                NetworkEvent::PeerDisconnected(peer_id)
            }
            // Handle other SwarmEvent variants
            _ => NetworkEvent::MetricsUpdate,
        }
    }
}
--- END FILE: libs\cpc-net\src\net.rs ---


--- START FILE: libs\cpc-net\src\storage.rs ---
//! Storage abstractions for Cooperative Peer Cloud
//!
//! Provides:
//! - Content-addressable storage interface
//! - LRU cache implementation
//! - Storage metrics
//!
//! Example usage:
//! ```
//! use cpc_lib::storage::{ContentStorage, LruStorage, StorageMetrics};
//! use cpc_lib::crypto::hash_content;
//!
//! let mut storage = LruStorage::new(1024 * 1024 * 100); // 100 MB
//! let data = b"Hello, world!";
//! let content_id = hash_content(data);
//!
//! // Store content
//! storage.put(&content_id, data.to_vec()).unwrap();
//!
//! // Retrieve content
//! let retrieved = storage.get(&content_id).unwrap();
//! assert_eq!(retrieved, data);
//!
//! // Check metrics
//! let metrics = storage.metrics();
//! println!("Storage hits: {}", metrics.hits);
//! ```

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use lru::LruCache;
use metrics::{Counter, Gauge};
use std::num::NonZeroUsize;

/// Content-addressable storage interface
pub trait ContentStorage {
    /// Store content and return its content ID
    fn put(&mut self, content_id: &[u8; 32], data: Vec<u8>) -> Result<(), StorageError>;
    
    /// Retrieve content by content ID
    fn get(&mut self, content_id: &[u8; 32]) -> Result<Vec<u8>, StorageError>;
    
    /// Check if content exists
    fn exists(&self, content_id: &[u8; 32]) -> bool;
    
    /// Delete content by content ID
    fn delete(&mut self, content_id: &[u8; 32]) -> Result<(), StorageError>;
    
    /// Get storage metrics
    fn metrics(&self) -> StorageMetrics;
}

/// Storage errors
#[derive(Debug)]
pub enum StorageError {
    NotFound,
    CapacityExceeded,
    IoError(String),
}

/// Storage metrics
#[derive(Default, Clone)]
pub struct StorageMetrics {
    pub items: u64,
    pub size_bytes: u64,
    pub hits: u64,
    pub misses: u64,
    pub evictions: u64,
}

/// In-memory LRU storage implementation
pub struct LruStorage {
    cache: LruCache<[u8; 32], Vec<u8>>,
    metrics: StorageMetrics,
    max_size: u64,
    current_size: u64,
}

impl LruStorage {
    /// Create new LRU storage with specified maximum size in bytes
    pub fn new(max_size: u64) -> Self {
        let cache = LruCache::new(NonZeroUsize::new(1000).unwrap()); // Default capacity
        LruStorage {
            cache,
            metrics: StorageMetrics::default(),
            max_size,
            current_size: 0,
        }
    }
}

impl ContentStorage for LruStorage {
    fn put(&mut self, content_id: &[u8; 32], data: Vec<u8>) -> Result<(), StorageError> {
        let data_size = data.len() as u64;
        
        // Check capacity
        if data_size > self.max_size {
            return Err(StorageError::CapacityExceeded);
        }
        
        // Evict items until there's enough space
        while self.current_size + data_size > self.max_size {
            if let Some((_, evicted_data)) = self.cache.pop_lru() {
                self.current_size -= evicted_data.len() as u64;
                self.metrics.evictions += 1;
            } else {
                return Err(StorageError::CapacityExceeded);
            }
        }
        
        // Store the item
        self.cache.put(*content_id, data.clone());
        self.current_size += data_size;
        self.metrics.items += 1;
        self.metrics.size_bytes += data_size;
        Ok(())
    }

    fn get(&mut self, content_id: &[u8; 32]) -> Result<Vec<u8>, StorageError> {
        if let Some(data) = self.cache.get(content_id) {
            self.metrics.hits += 1;
            Ok(data.clone())
        } else {
            self.metrics.misses += 1;
            Err(StorageError::NotFound)
        }
    }

    fn exists(&self, content_id: &[u8; 32]) -> bool {
        self.cache.contains(content_id)
    }

    fn delete(&mut self, content_id: &[u8; 32]) -> Result<(), StorageError> {
        if let Some(data) = self.cache.pop(content_id) {
            self.current_size -= data.len() as u64;
            self.metrics.items -= 1;
            self.metrics.size_bytes -= data.len() as u64;
            Ok(())
        } else {
            Err(StorageError::NotFound)
        }
    }

    fn metrics(&self) -> StorageMetrics {
        self.metrics.clone()
    }
}

/// Metrics collector for storage
pub struct StorageMetricsCollector {
    metrics: Arc<Mutex<StorageMetrics>>,
    items_gauge: Gauge,
    size_gauge: Gauge,
    hits_counter: Counter,
    misses_counter: Counter,
    evictions_counter: Counter,
}

impl StorageMetricsCollector {
    pub fn new() -> Self {
        // Initialize metrics (actual implementation would register with metrics registry)
        StorageMetricsCollector {
            metrics: Arc::new(Mutex::new(StorageMetrics::default())),
            items_gauge: Gauge::noop(),
            size_gauge: Gauge::noop(),
            hits_counter: Counter::noop(),
            misses_counter: Counter::noop(),
            evictions_counter: Counter::noop(),
        }
    }

    pub fn update(&self) {
        let metrics = self.metrics.lock().unwrap();
        self.items_gauge.set(metrics.items as f64);
        self.size_gauge.set(metrics.size_bytes as f64);
        // Counters are cumulative so we don't need to update them here
    }
}
--- END FILE: libs\cpc-net\src\storage.rs ---


--- START FILE: libs\cpc-net\src\grpc\client.rs ---
use tonic::transport::{Channel, Endpoint};
use crate::grpc::internal::{
    node_orchestration_client::NodeOrchestrationClient, 
    NodeRegistrationRequest,
    HealthCheckRequest,
    MetricsUpdate,
    ReplicationRequest,
    ReplicationStatus,
    MetricsAck,
    ReplicationAck,
    HealthCheckResponse,
    NodeRegistrationResponse
};

pub struct OrchestratorClient {
    client: NodeOrchestrationClient<Channel>,
}

impl OrchestratorClient {
    pub async fn connect(addr: String) -> Result<Self, tonic::transport::Error> {
        let channel = Endpoint::from_shared(addr)?
            .connect()
            .await?;
        let client = NodeOrchestrationClient::new(channel);
        Ok(Self { client })
    }
    
    pub async fn register_node(
        &mut self, 
        request: NodeRegistrationRequest
    ) -> Result<NodeRegistrationResponse, tonic::Status> {
        let response = self.client.register_node(request).await?;
        Ok(response.into_inner())
    }
    
    pub async fn health_check(
        &mut self, 
        request: HealthCheckRequest
    ) -> Result<HealthCheckResponse, tonic::Status> {
        let response = self.client.health_check(request).await?;
        Ok(response.into_inner())
    }
    
    pub async fn stream_metrics(
        &mut self, 
        request: tonic::Streaming<MetricsUpdate>
    ) -> Result<MetricsAck, tonic::Status> {
        let response = self.client.stream_metrics(request).await?;
        Ok(response.into_inner())
    }
    
    pub async fn replicate_content(
        &mut self, 
        request: ReplicationRequest
    ) -> Result<ReplicationStatus, tonic::Status> {
        let response = self.client.replicate_content(request).await?;
        Ok(response.into_inner())
    }
    
    pub async fn report_replication(
        &mut self, 
        request: ReplicationStatus
    ) -> Result<ReplicationAck, tonic::Status> {
        let response = self.client.report_replication(request).await?;
        Ok(response.into_inner())
    }
}
--- END FILE: libs\cpc-net\src\grpc\client.rs ---


--- START FILE: libs\cpc-net\src\grpc\error.rs ---
use thiserror::Error;

#[derive(Debug, Error)]
pub enum GrpcError {
    #[error("Connection error: {0}")]
    ConnectionError(#[from] tonic::transport::Error),
    
    #[error("gRPC status: {0}")]
    Status(#[from] tonic::Status),
    
    #[error("Retry limit exceeded")]
    RetryExceeded,
    
    #[error("Fatal error: {0}")]
    Fatal(String),
}

impl GrpcError {
    pub fn is_retryable(&self) -> bool {
        match self {
            Self::ConnectionError(_) => true,
            Self::Status(status) => matches!(
                status.code(),
                tonic::Code::Unavailable | tonic::Code::DeadlineExceeded
            ),
            _ => false,
        }
    }
}
--- END FILE: libs\cpc-net\src\grpc\error.rs ---


--- START FILE: libs\cpc-net\src\grpc\mod.rs ---
pub mod internal {
    tonic::include_proto!("cpc.internal");
}

pub mod client;
pub mod server;
pub mod error;
--- END FILE: libs\cpc-net\src\grpc\mod.rs ---


--- START FILE: libs\cpc-net\src\grpc\server.rs ---
use tonic::{Request, Response, Status, Streaming};
use crate::grpc::internal::{
    node_orchestration_server::{NodeOrchestration, NodeOrchestrationServer},
    *,
};

pub struct OrchestrationService;

#[tonic::async_trait]
impl NodeOrchestration for OrchestrationService {
    async fn register_node(
        &self,
        request: Request<NodeRegistrationRequest>,
    ) -> Result<Response<NodeRegistrationResponse>, Status> {
        let req = request.into_inner();
        // TODO: Implement actual registration logic
        let response = NodeRegistrationResponse {
            success: true,
            message: format!("Node {} registered successfully", req.node_id),
            assigned_id: req.node_id,
        };
        Ok(Response::new(response))
    }
    
    async fn health_check(
        &self,
        request: Request<HealthCheckRequest>,
    ) -> Result<Response<HealthCheckResponse>, Status> {
        let req = request.into_inner();
        // TODO: Implement actual health check
        let response = HealthCheckResponse {
            healthy: true,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };
        Ok(Response::new(response))
    }
    
    async fn stream_metrics(
        &self,
        request: Request<Streaming<MetricsUpdate>>,
    ) -> Result<Response<MetricsAck>, Status> {
        let mut stream = request.into_inner();
        while let Some(update) = stream.message().await? {
            // TODO: Process metrics update
            println!("Received metrics: {:?}", update);
        }
        Ok(Response::new(MetricsAck { received: true }))
    }
    
    async fn replicate_content(
        &self,
        request: Request<ReplicationRequest>,
    ) -> Result<Response<ReplicationStatus>, Status> {
        let req = request.into_inner();
        // TODO: Implement replication logic
        let response = ReplicationStatus {
            content_id: req.content_id,
            node_id: "".to_string(), // Will be set by node
            status: 2, // IN_PROGRESS
            message: "Replication started".to_string(),
        };
        Ok(Response::new(response))
    }
    
    async fn report_replication(
        &self,
        request: Request<ReplicationStatus>,
    ) -> Result<Response<ReplicationAck>, Status> {
        let req = request.into_inner();
        // TODO: Process replication report
        println!("Replication status: {:?}", req);
        Ok(Response::new(ReplicationAck { received: true }))
    }
}

pub fn server() -> NodeOrchestrationServer<OrchestrationService> {
    NodeOrchestrationServer::new(OrchestrationService)
}
--- END FILE: libs\cpc-net\src\grpc\server.rs ---


--- START FILE: libs\cpc-protos\internal.proto ---
syntax = "proto3";

package cpc.internal;

// Node Orchestration Service
service NodeOrchestration {
  // Registers a new node with the orchestrator
  rpc RegisterNode(NodeRegistrationRequest) returns (NodeRegistrationResponse);
  
  // Periodically sent by nodes to confirm liveness
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  
  // Streams node metrics to orchestrator
  rpc StreamMetrics(stream MetricsUpdate) returns (MetricsAck);
  
  // Initiates content replication to target nodes
  rpc ReplicateContent(ReplicationRequest) returns (ReplicationStatus);
  
  // Reports replication status to orchestrator
  rpc ReportReplication(ReplicationStatus) returns (ReplicationAck);
}

// Node Registration
message NodeRegistrationRequest {
  string node_id = 1;
  Resources resources = 2;
  string location = 3;  // e.g., "us-west", "eu-central"
  repeated string capabilities = 4;  // e.g., ["storage", "compute"]
}

message NodeRegistrationResponse {
  bool success = 1;
  string message = 2;
  string assigned_id = 3;  // Orchestrator-assigned node ID
}

// Health Checks
message HealthCheckRequest {
  string node_id = 1;
}

message HealthCheckResponse {
  bool healthy = 1;
  uint64 timestamp = 2;  // Unix timestamp
}

// Metrics
message MetricsUpdate {
  string node_id = 1;
  double cpu_usage = 2;  // percentage
  uint64 memory_used = 3;  // in MB
  uint64 memory_total = 4;  // in MB
  uint64 storage_used = 5;  // in GB
  uint64 storage_total = 6;  // in GB
  uint64 bandwidth_up = 7;  // Mbps
  uint64 bandwidth_down = 8;  // Mbps
}

message MetricsAck {
  bool received = 1;
}

// Replication
message ReplicationRequest {
  string content_id = 1;
  repeated string target_node_ids = 2;
  uint32 priority = 3;  // 1-5 (5 = highest)
}

message ReplicationStatus {
  string content_id = 1;
  string node_id = 2;
  enum Status {
    SUCCESS = 0;
    FAILED = 1;
    IN_PROGRESS = 2;
  }
  Status status = 3;
  string message = 4;
}

message ReplicationAck {
  bool received = 1;
}

// Resource definition
message Resources {
  uint64 memory = 1;  // in MB
  uint64 storage = 2;  // in GB
  uint32 cores = 3;
  uint64 bandwidth = 4;  // in Mbps
}
--- END FILE: libs\cpc-protos\internal.proto ---