//! Literal values for Shtairir registry
//! 
//! This module defines the ValueLiteral enum, which represents literal values
//! that can appear in Shtairir manifests and module definitions.

use std::collections::BTreeMap;
use serde::{Deserialize, Serialize};

/// Represents a literal value in Shtairir manifests for serialization/deserialization
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ValueLiteral {
    /// 64-bit signed integer
    I64(i64),
    /// 64-bit floating point number
    F64(f64),
    /// Boolean value
    Bool(bool),
    /// String value
    String(String),
    /// Array of values (for serialization)
    Array(Vec<ValueLiteral>),
    /// Object with string keys and values (for serialization)
    Object(BTreeMap<String, ValueLiteral>),
    /// Null value
    Null,
}

impl ValueLiteral {
    /// Create a new string value
    pub fn string(s: impl Into<String>) -> Self {
        ValueLiteral::String(s.into())
    }
    
    /// Create a new integer value
    pub fn i64(n: i64) -> Self {
        ValueLiteral::I64(n)
    }
    
    /// Create a new float value
    pub fn f64(n: f64) -> Self {
        ValueLiteral::F64(n)
    }
    
    /// Create a new boolean value
    pub fn bool(b: bool) -> Self {
        ValueLiteral::Bool(b)
    }
    
    /// Create a new array value
    pub fn array(values: Vec<ValueLiteral>) -> Self {
        ValueLiteral::Array(values)
    }
    
    /// Create a new object value
    pub fn object(map: BTreeMap<String, ValueLiteral>) -> Self {
        ValueLiteral::Object(map)
    }
    
    /// Create a new null value
    pub fn null() -> Self {
        ValueLiteral::Null
    }
}

impl Default for ValueLiteral {
    fn default() -> Self {
        ValueLiteral::Null
    }
}

/// Conversion from Value to ValueLiteral
impl From<super::value::Value> for ValueLiteral {
    fn from(value: super::value::Value) -> Self {
        match value {
            super::value::Value::I64(v) => ValueLiteral::I64(v),
            super::value::Value::F64(v) => ValueLiteral::F64(v),
            super::value::Value::Bool(v) => ValueLiteral::Bool(v),
            super::value::Value::String(v) => ValueLiteral::String(v),
            super::value::Value::Bytes(_) => ValueLiteral::String("<bytes>".to_string()), // Simplified representation
            super::value::Value::Decimal(v) => ValueLiteral::String(v.to_string()),
            super::value::Value::DateTime(v) => ValueLiteral::String(v.to_rfc3339()),
            super::value::Value::Duration(v) => ValueLiteral::String(format!("{:?}", v)),
            super::value::Value::Uuid(v) => ValueLiteral::String(v.to_string()),
            super::value::Value::Object(map) => {
                let literal_map = map.into_iter()
                    .map(|(k, v)| (k, ValueLiteral::from(v)))
                    .collect();
                ValueLiteral::Object(literal_map)
            },
            super::value::Value::Array(vec) => {
                let literal_vec = vec.into_iter()
                    .map(ValueLiteral::from)
                    .collect();
                ValueLiteral::Array(literal_vec)
            },
            super::value::Value::Null => ValueLiteral::Null,
            super::value::Value::List(vec) => {
                let literal_vec = vec.into_iter()
                    .map(ValueLiteral::from)
                    .collect();
                ValueLiteral::Array(literal_vec)
            },
            super::value::Value::Map(map) => {
                let literal_map = map.into_iter()
                    .map(|(k, v)| (k, ValueLiteral::from(v)))
                    .collect();
                ValueLiteral::Object(literal_map)
            },
            super::value::Value::Option(opt) => match opt {
                Some(v) => ValueLiteral::from(*v),
                None => ValueLiteral::Null,
            },
            super::value::Value::Tuple(vec) => {
                let literal_vec = vec.into_iter()
                    .map(ValueLiteral::from)
                    .collect();
                ValueLiteral::Array(literal_vec)
            },
            super::value::Value::Struct(s) => {
                let literal_map = s.fields.into_iter()
                    .map(|(k, v)| (k, ValueLiteral::from(v)))
                    .collect();
                ValueLiteral::Object(literal_map)
            },
            super::value::Value::Enum(e) => match e.value {
                Some(v) => ValueLiteral::from(*v),
                None => ValueLiteral::String(format!("{}::{}", e.type_name, e.variant_name)),
            },
            super::value::Value::Stream(v) => ValueLiteral::from(*v),
            super::value::Value::Event(v) => ValueLiteral::from(*v),
        }
    }
}

/// Conversion from ValueLiteral to Value
impl Into<super::value::Value> for ValueLiteral {
    fn into(self) -> super::value::Value {
        match self {
            ValueLiteral::I64(v) => super::value::Value::I64(v),
            ValueLiteral::F64(v) => super::value::Value::F64(v),
            ValueLiteral::Bool(v) => super::value::Value::Bool(v),
            ValueLiteral::String(v) => super::value::Value::String(v),
            ValueLiteral::Array(vec) => {
                let value_vec = vec.into_iter()
                    .map(|v| v.into())
                    .collect();
                super::value::Value::Array(value_vec)
            },
            ValueLiteral::Object(map) => {
                let value_map = map.into_iter()
                    .map(|(k, v)| (k, v.into()))
                    .collect();
                super::value::Value::Object(value_map)
            },
            ValueLiteral::Null => super::value::Value::Null,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;
    
    #[test]
    fn test_value_literal_creation() {
        let str_val = ValueLiteral::string("hello");
        assert_eq!(str_val, ValueLiteral::String("hello".to_string()));
        
        let int_val = ValueLiteral::i64(42);
        assert_eq!(int_val, ValueLiteral::I64(42));
        
        let bool_val = ValueLiteral::bool(true);
        assert_eq!(bool_val, ValueLiteral::Bool(true));
        
        let null_val = ValueLiteral::null();
        assert_eq!(null_val, ValueLiteral::Null);
    }
    
    #[test]
    fn test_value_literal_object() {
        let mut map = BTreeMap::new();
        map.insert("key1".to_string(), ValueLiteral::string("value1"));
        map.insert("key2".to_string(), ValueLiteral::i64(42));
        
        let obj = ValueLiteral::object(map.clone());
        assert_eq!(obj, ValueLiteral::Object(map));
    }
    
    #[test]
    fn test_value_literal_array() {
        let values = vec![ValueLiteral::i64(1), ValueLiteral::i64(2), ValueLiteral::i64(3)];
        let array = ValueLiteral::array(values.clone());
        assert_eq!(array, ValueLiteral::Array(values));
    }
    
    #[test]
    fn test_conversion_from_value() {
        use super::super::value::Value;
        
        let value = Value::i64(42);
        let literal: ValueLiteral = value.into();
        assert_eq!(literal, ValueLiteral::I64(42));
        
        let value = Value::string("hello");
        let literal: ValueLiteral = value.into();
        assert_eq!(literal, ValueLiteral::String("hello".to_string()));
    }
    
    #[test]
    fn test_conversion_to_value() {
        let literal = ValueLiteral::i64(42);
        let value: super::super::value::Value = literal.into();
        assert_eq!(value, super::super::value::Value::I64(42));
        
        let literal = ValueLiteral::string("hello");
        let value: super::super::value::Value = literal.into();
        assert_eq!(value, super::super::value::Value::String("hello".to_string()));
    }
}